"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const logger_1 = require("../../../logger");
const AbstractSession_1 = require("../session/AbstractSession");
const https = require("https");
const http = require("http");
const Headers_1 = require("./Headers");
const RestConstants_1 = require("./RestConstants");
const expect_1 = require("../../../expect");
const path = require("path");
const RestClientError_1 = require("./RestClientError");
const perf_timing_1 = require("@zowe/perf-timing");
const io_1 = require("../../../io");
const operations_1 = require("../../../operations");
const utilities_1 = require("../../../utilities");
/**
 * Class to handle http(s) requests, build headers, collect data, report status codes, and header responses
 * and passes control to session object for maintaining connection information (tokens, checking for timeout, etc...)
 * @export
 * @abstract
 * @class AbstractRestClient
 */
class AbstractRestClient {
    /**
     * Creates an instance of AbstractRestClient.
     * @param {AbstractSession} mSession - representing connection to this api
     * @memberof AbstractRestClient
     */
    constructor(mSession) {
        this.mSession = mSession;
        /**
         * Contains buffered data from REST chucks
         * @private
         * @type {Buffer}
         * @memberof AbstractRestClient
         */
        this.mData = Buffer.from([]);
        /**
         * Bytes received from the server response so far
         * @private
         * @type {ITaskWithStatus}
         * @memberof AbstractRestClient
         */
        this.mBytesReceived = 0;
        expect_1.ImperativeExpect.toNotBeNullOrUndefined(mSession);
        this.mLogger = logger_1.Logger.getImperativeLogger();
        this.mIsJson = false;
    }
    /**
     * Perform the actual http REST call with appropriate user input
     * @param {string} resource - URI for this request
     * @param {string} request - REST request type GET|PUT|POST|DELETE
     * @param {any[]} reqHeaders - option headers to include with request
     * @param {any} writeData - data to write on this REST request
     * @param responseStream - stream for incoming response data from the server. If specified, response data will not be buffered
     * @param requestStream - stream for outgoing request data to the server
     * @param normalizeResponseNewLines - streaming only - true if you want newlines to be \r\n on windows
     *                                    when receiving data from the server to responseStream. Don't set this for binary responses
     * @param normalizeRequestNewLines -  streaming only - true if you want \r\n to be replaced with \n when sending
     *                                    data to the server from requestStream. Don't set this for binary requests
     * @param task - task that will automatically be updated to report progress of upload or download to user
     * @throws  if the request gets a status code outside of the 200 range
     *          or other connection problems occur (e.g. connection refused)
     */
    performRest(resource, request, reqHeaders, writeData, responseStream, requestStream, normalizeResponseNewLines, normalizeRequestNewLines, task) {
        return new Promise((resolve, reject) => {
            const timingApi = perf_timing_1.PerfTiming.api;
            if (perf_timing_1.PerfTiming.isEnabled) {
                // Marks point START
                timingApi.mark("START_PERFORM_REST");
            }
            // save for logging
            this.mResource = resource;
            this.mRequest = request;
            this.mReqHeaders = reqHeaders;
            this.mWriteData = writeData;
            this.mRequestStream = requestStream;
            this.mResponseStream = responseStream;
            this.mNormalizeRequestNewlines = normalizeRequestNewLines;
            this.mNormalizeResponseNewlines = normalizeResponseNewLines;
            this.mTask = task;
            // got a new promise
            this.mResolve = resolve;
            this.mReject = reject;
            expect_1.ImperativeExpect.toBeDefinedAndNonBlank(resource, "resource");
            expect_1.ImperativeExpect.toBeDefinedAndNonBlank(request, "request");
            expect_1.ImperativeExpect.toBeEqual(requestStream != null && writeData != null, false, "You cannot specify both writeData and writeStream");
            const options = this.buildOptions(resource, request, reqHeaders);
            /**
             * Perform the actual http request
             */
            let clientRequest;
            if (this.session.ISession.protocol === AbstractSession_1.AbstractSession.HTTPS_PROTOCOL) {
                clientRequest = https.request(options, this.requestHandler.bind(this));
            }
            else if (this.session.ISession.protocol === AbstractSession_1.AbstractSession.HTTP_PROTOCOL) {
                clientRequest = http.request(options, this.requestHandler.bind(this));
            }
            /**
             * For a REST request which includes writing raw data to the http server,
             * write the data via http request.
             */
            if (writeData != null) {
                this.log.debug("will write data for request");
                /**
                 * If the data is JSON, translate to text before writing
                 */
                if (this.mIsJson) {
                    this.log.debug("writing JSON for request");
                    this.log.trace("JSON body: %s", JSON.stringify(writeData));
                    clientRequest.write(JSON.stringify(writeData));
                }
                else {
                    clientRequest.write(writeData);
                }
            }
            /**
             * Invoke any onError method whenever an error occurs on writing
             */
            clientRequest.on("error", (errorResponse) => {
                reject(this.populateError({
                    msg: "http(s) request error event called",
                    causeErrors: errorResponse,
                    source: "client"
                }));
            });
            if (requestStream != null) {
                // if the user requested streaming write of data to the request,
                // write the data chunk by chunk to the server
                let bytesUploaded = 0;
                requestStream.on("data", (data) => {
                    this.log.debug("Writing data chunk of length %d from requestStream to clientRequest", data.byteLength);
                    if (this.mNormalizeRequestNewlines) {
                        this.log.debug("Normalizing new lines in request chunk to \\n");
                        data = Buffer.from(data.toString().replace(/\r?\n/g, "\n"));
                    }
                    if (this.mTask != null) {
                        bytesUploaded += data.byteLength;
                        this.mTask.statusMessage = utilities_1.TextUtils.formatMessage("Uploading %d B", bytesUploaded);
                        if (this.mTask.percentComplete < operations_1.TaskProgress.NINETY_PERCENT) {
                            // we don't know how far along we are but increment the percentage to
                            // show we are making progress
                            this.mTask.percentComplete++;
                        }
                    }
                    clientRequest.write(data);
                });
                requestStream.on("error", (streamError) => {
                    this.log.error("Error encountered reading requestStream: " + streamError);
                    reject(this.populateError({
                        msg: "Error reading requestStream",
                        causeErrors: streamError,
                        source: "client"
                    }));
                });
                requestStream.on("end", () => {
                    this.log.debug("Finished reading requestStream");
                    // finish the request
                    clientRequest.end();
                });
            }
            else {
                // otherwise we're done with the request
                clientRequest.end();
            }
            if (perf_timing_1.PerfTiming.isEnabled) {
                // Marks point END
                timingApi.mark("END_PERFORM_REST");
                timingApi.measure("performRest: $resource", "START_PERFORM_REST", "END_PERFORM_REST");
            }
        });
    }
    /**
     * Append specific headers for all requests by overriding this implementation
     * @protected
     * @param {(any[] | undefined)} headers - list of headers
     * @returns {any[]} - completed list of headers
     * @memberof AbstractRestClient
     */
    appendHeaders(headers) {
        if (headers == null) {
            return [];
        }
        else {
            return headers;
        }
    }
    /**
     * Process and customize errors encountered in your client.
     * This is called any time an error is thrown from a failed Rest request using this client.
     * error before receiving any response body from the API.
     * You can use this, for example, to set the error tag for you client or add additional
     * details to the error message.
     * If you return null or undefined, Imperative will use the default error generated
     * for your failed request.
     * @protected
     * @param {IImperativeError} error - the error encountered by the client
     * @memberof AbstractRestClient
     * @returns {IImperativeError} processedError - the error with the fields set the way you want them
     */
    processError(error) {
        this.log.debug("Default stub for processError was called for rest client %s - processError was not overwritten", this.constructor.name);
        return undefined; // do nothing by default
    }
    /**
     * Build http(s) options based upon session settings and request.
     * @private
     * @param {string} resource - URI for this request
     * @param {string} request - REST request type GET|PUT|POST|DELETE
     * @param {any[]} reqHeaders - option headers to include with request
     * @returns {IHTTPSOptions} - completed options object
     * @memberof AbstractRestClient
     */
    buildOptions(resource, request, reqHeaders) {
        /**
         * HTTPS REST request options
         */
        let options = {
            headers: {},
            hostname: this.session.ISession.hostname,
            method: request,
            /* Posix.join forces forward-slash delimiter on Windows.
             * Path join is ok for just the resource part of the URL.
             * We also eliminate any whitespace typos at the beginning
             * or end of basePath or resource.
             */
            path: path.posix.join(path.posix.sep, this.session.ISession.basePath.trim(), resource.trim()),
            port: this.session.ISession.port,
            rejectUnauthorized: this.session.ISession.rejectUnauthorized
        };
        // NOTE(Kelosky): This cannot be set for http requests
        // options.agent = new https.Agent({secureProtocol: this.session.ISession.secureProtocol});
        // NOTE(Kelosky): we can bring certificate implementation back whenever we port tests and
        // convert for imperative usage
        /**
         * Allow our session's defined identity validator run
         */
        if (this.session.ISession.checkServerIdentity) {
            this.log.trace("Check Server Identity Disabled (Allowing Mismatched Domains)");
            options.checkServerIdentity = this.session.ISession.checkServerIdentity;
        }
        /**
         * Here is where we conditionally perform our HTTP REST request using basic authentication or the stored
         * cookie in our session object.
         */
        if (this.session.ISession.type === AbstractSession_1.AbstractSession.TYPE_BASIC ||
            this.session.ISession.type === AbstractSession_1.AbstractSession.TYPE_TOKEN) {
            if (this.session.ISession.tokenValue) {
                this.log.trace("Using cookie authentication with token %s", this.session.ISession.tokenValue);
                const headerKeys = Object.keys(Headers_1.Headers.COOKIE_AUTHORIZATION);
                const authentication = this.session.ISession.tokenValue;
                headerKeys.forEach((property) => {
                    options.headers[property] = authentication;
                });
            }
            else {
                this.log.trace("Using basic authentication");
                const headerKeys = Object.keys(Headers_1.Headers.BASIC_AUTHORIZATION);
                const authentication = AbstractSession_1.AbstractSession.BASIC_PREFIX + this.session.ISession.base64EncodedAuth;
                headerKeys.forEach((property) => {
                    options.headers[property] = authentication;
                });
            }
        }
        // for all headers passed into this request, append them to our options object
        reqHeaders = this.appendHeaders(reqHeaders);
        options = this.appendInputHeaders(options, reqHeaders);
        // set transfer flags
        this.setTransferFlags(options.headers);
        const logResource = path.posix.join(path.posix.sep, (this.session.ISession.basePath == null ? "" : this.session.ISession.basePath), resource);
        this.log.trace("Rest request: %s %s:%s%s %s", request, this.session.ISession.hostname, this.session.ISession.port, logResource, this.session.ISession.user ? "as user " + this.session.ISession.user : "");
        return options;
    }
    /**
     * Callback from http(s).request
     * @private
     * @param {*} res - https response
     * @memberof AbstractRestClient
     */
    requestHandler(res) {
        this.mResponse = res;
        if (this.requestSuccess) {
            if (this.session.ISession.type === AbstractSession_1.AbstractSession.TYPE_TOKEN) {
                if (RestConstants_1.RestConstants.PROP_COOKIE in this.response.headers) {
                    this.session.storeCookie(this.response.headers[RestConstants_1.RestConstants.PROP_COOKIE]);
                }
            }
            if (this.response.headers != null) {
                if (Headers_1.Headers.CONTENT_LENGTH in this.response.headers) {
                    this.mContentLength = this.response.headers[Headers_1.Headers.CONTENT_LENGTH];
                    this.log.debug("Content length of response is: " + this.mContentLength);
                }
                if (Headers_1.Headers.CONTENT_LENGTH.toLowerCase() in this.response.headers) {
                    this.mContentLength = this.response.headers[Headers_1.Headers.CONTENT_LENGTH.toLowerCase()];
                    this.log.debug("Content length of response is: " + this.mContentLength);
                }
            }
        }
        if (this.mResponseStream != null) {
            this.mResponseStream.on("error", (streamError) => {
                this.mReject(this.populateError({
                    msg: "Error writing to responseStream",
                    causeErrors: streamError,
                    source: "client"
                }));
            });
        }
        /**
         * Invoke any onData method whenever data becomes available
         */
        res.on("data", (dataResponse) => {
            this.onData(dataResponse);
        });
        /**
         * Invoke any onEnd method whenever all response data has been received
         */
        res.on("end", () => {
            this.onEnd();
        });
    }
    /**
     * Method to accumulate and buffer http request response data until our
     * onEnd method is invoked, at which point all response data has been accounted for.
     * NOTE(Kelosky): this method may be invoked multiple times.
     * @private
     * @param {Buffer} respData - any datatype and content
     * @memberof AbstractRestClient
     */
    onData(respData) {
        this.log.trace("Data chunk received...");
        this.mBytesReceived += respData.byteLength;
        if (this.requestFailure || this.mResponseStream == null) {
            // buffer the data if we are not streaming
            // or if we encountered an error, since the rest client
            // relies on any JSON error to be in the this.dataString field
            this.mData = Buffer.concat([this.mData, respData]);
        }
        else {
            this.log.debug("Streaming data chunk of length " + respData.length + " to response stream");
            if (this.mNormalizeResponseNewlines) {
                this.log.debug("Normalizing new lines in data chunk to operating system appropriate line endings");
                respData = Buffer.from(io_1.IO.processNewlines(respData.toString()));
            }
            if (this.mTask != null) {
                // update the progress task if provided by the requester
                if (this.mContentLength != null) {
                    this.mTask.percentComplete = Math.floor(operations_1.TaskProgress.ONE_HUNDRED_PERCENT *
                        (this.mBytesReceived / this.mContentLength));
                    this.mTask.statusMessage = utilities_1.TextUtils.formatMessage("Downloading %d of %d B", this.mBytesReceived, this.mContentLength);
                }
                else {
                    this.mTask.statusMessage = utilities_1.TextUtils.formatMessage("Downloaded %d of ? B", this.mBytesReceived);
                    if (this.mTask.percentComplete < operations_1.TaskProgress.NINETY_PERCENT) {
                        // we don't know how far along we are but increment the percentage to
                        // show that we are making progress
                        this.mTask.percentComplete++;
                    }
                }
            }
            // write the chunk to the response stream if requested
            this.mResponseStream.write(respData);
        }
    }
    /**
     * Method that must be implemented to extend the IRestClient class.  This is the client specific implementation
     * for what action to perform after all response data has been collected.
     * @private
     * @memberof AbstractRestClient
     */
    onEnd() {
        this.log.debug("onEnd() called for rest client %s", this.constructor.name);
        if (this.mTask != null) {
            this.mTask.percentComplete = operations_1.TaskProgress.ONE_HUNDRED_PERCENT;
            this.mTask.stageName = operations_1.TaskStage.COMPLETE;
        }
        if (this.mResponseStream != null) {
            this.log.debug("Ending response stream");
            this.mResponseStream.end();
        }
        if (this.requestFailure) {
            // Reject the promise with an error
            const errorCode = this.response == null ? undefined : this.response.statusCode;
            this.mReject(this.populateError({
                msg: "Rest API failure with HTTP(S) status " + errorCode,
                causeErrors: this.dataString,
                source: "http"
            }));
        }
        else {
            this.mResolve(this.dataString);
        }
    }
    /**
     * Construct a throwable rest client error with all "relevant" diagnostic information.
     * The caller should have the session, so not all input fields are present on the error
     * response. Only the set required to understand "what may have gone wrong".
     *
     * The "exit" point for the implementation error override will also be called here. The
     * implementation can choose to transform the IImperativeError details however they see
     * fit.
     *
     * @param {IRestClientError} error - The base request error. It is expected to already have msg,
     *                                   causeErrors, and the error source pre-populated.
     * @param {*} [nodeClientError] - If the source is a node http client error (meaning the request
     *                                did not make it to the remote system) this parameter should be
     *                                populated.
     * @returns {RestClientError} - The error that can be thrown or rejected.
     */
    populateError(error, nodeClientError) {
        // Final error object parameters
        let finalError = error;
        // @deprecated - extract the status code - now moved to HTTP status.
        const errorCode = this.response == null ? undefined : this.response.statusCode;
        // start off by coercing the request details to string in case an error is encountered trying
        // to stringify / inspect them
        let headerDetails = this.mReqHeaders + "";
        let payloadDetails = this.mWriteData + "";
        try {
            headerDetails = JSON.stringify(this.mReqHeaders);
            payloadDetails = util_1.inspect(this.mWriteData, { depth: null });
        }
        catch (stringifyError) {
            this.log.error("Error encountered trying to parse details for REST request error:\n %s", util_1.inspect(stringifyError, { depth: null }));
        }
        // Populate the "relevant" fields - caller will have the session, so
        // no need to duplicate "everything" here, just host/port for easy diagnosis
        finalError.errorCode = errorCode;
        finalError.port = this.mSession.ISession.port;
        finalError.host = this.mSession.ISession.hostname;
        finalError.basePath = this.mSession.ISession.basePath;
        finalError.httpStatus = errorCode;
        finalError.errno = (nodeClientError != null) ? nodeClientError.errno : undefined;
        finalError.syscall = (nodeClientError != null) ? nodeClientError.syscall : undefined;
        finalError.payload = this.mWriteData;
        finalError.headers = this.mReqHeaders;
        finalError.resource = this.mResource;
        finalError.request = this.mRequest;
        // Construct a formatted details message
        const detailMessage = ((finalError.source === "client") ?
            `HTTP(S) client encountered an error. Request could not be initiated to host.\n` +
                `Review connection details (host, port) and ensure correctness.`
            :
                `HTTP(S) error status "${finalError.httpStatus}" received.\n` +
                    `Review request details (resource, base path, credentials, payload) and ensure correctness.`) +
            "\n" +
            "\nHost:      " + finalError.host +
            "\nPort:      " + finalError.port +
            "\nBase Path: " + finalError.basePath +
            "\nResource:  " + finalError.resource +
            "\nRequest:   " + finalError.request +
            "\nHeaders:   " + headerDetails +
            "\nPayload:   " + payloadDetails;
        finalError.additionalDetails = detailMessage;
        // Allow implementation to modify the error as necessary
        // TODO - this is probably no longer necessary after adding the custom
        // TODO - error object, but it is left for compatibility.
        const processedError = this.processError(error);
        if (processedError != null) {
            this.log.debug("Error was processed by overridden processError method in RestClient %s", this.constructor.name);
            finalError = Object.assign({}, finalError, processedError);
        }
        // Return the error object
        return new RestClientError_1.RestClientError(finalError);
    }
    /**
     * Appends output headers to the http(s) request
     * @private
     * @param {IHTTPSOptions} options - partially populated options objects
     * @param {any[]} [reqHeaders] - input headers for request on outgoing request
     * @returns {IHTTPSOptions} - with populated headers
     * @memberof AbstractRestClient
     */
    appendInputHeaders(options, reqHeaders) {
        this.log.trace("appendInputHeaders called with options on rest client %s", JSON.stringify(options), this.constructor.name);
        if (reqHeaders && reqHeaders.length > 0) {
            reqHeaders.forEach((reqHeader) => {
                const requestHeaderKeys = Object.keys(reqHeader);
                requestHeaderKeys.forEach((property) => {
                    options.headers[property] = reqHeader[property];
                });
            });
        }
        return options;
    }
    /**
     * Determine whether we should stringify or leave writable data alone
     * @private
     * @param {http.OutgoingHttpHeaders} headers - options containing populated headers
     * @memberof AbstractRestClient
     */
    setTransferFlags(headers) {
        if ((headers[Headers_1.Headers.CONTENT_TYPE]) != null) {
            const contentType = headers[Headers_1.Headers.CONTENT_TYPE];
            if (contentType === Headers_1.Headers.APPLICATION_JSON[Headers_1.Headers.CONTENT_TYPE]) {
                this.mIsJson = true;
            }
            else if (contentType === Headers_1.Headers.OCTET_STREAM[Headers_1.Headers.CONTENT_TYPE]) {
                this.log.debug("Found octet-stream header in request. Will write in binary mode");
            }
        }
    }
    /**
     * Return whether or not a REST request was successful by HTTP status code
     * @readonly
     * @type {boolean}
     * @memberof AbstractRestClient
     */
    get requestSuccess() {
        if (this.response == null) {
            return false;
        }
        else {
            return (this.response.statusCode >= RestConstants_1.RestConstants.HTTP_STATUS_200 &&
                this.response.statusCode < RestConstants_1.RestConstants.HTTP_STATUS_300);
        }
    }
    /**
     * Return whether or not a REST request was successful by HTTP status code
     * @readonly
     * @type {boolean}
     * @memberof AbstractRestClient
     */
    get requestFailure() {
        return !this.requestSuccess;
    }
    /**
     * Return http(s) response body as a buffer
     * @readonly
     * @type {Buffer}
     * @memberof AbstractRestClient
     */
    get data() {
        return this.mData;
    }
    /**
     * Return http(s) response body as a string
     * @readonly
     * @type {string}
     * @memberof AbstractRestClient
     */
    get dataString() {
        if (this.data == null) {
            return undefined;
        }
        return this.data.toString("utf8");
    }
    /**
     * Return http(s) response object
     * @readonly
     * @type {*}
     * @memberof AbstractRestClient
     */
    get response() {
        return this.mResponse;
    }
    /**
     * Return this session object
     * @readonly
     * @type {Session}
     * @memberof AbstractRestClient
     */
    get session() {
        return this.mSession;
    }
    /**
     * Return the logger object for ease of reference
     * @readonly
     * @type {Logger}
     * @memberof AbstractRestClient
     */
    get log() {
        return this.mLogger;
    }
}
exports.AbstractRestClient = AbstractRestClient;
//# sourceMappingURL=AbstractRestClient.js.map