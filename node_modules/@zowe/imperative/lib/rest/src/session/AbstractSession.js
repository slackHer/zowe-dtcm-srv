"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../../../logger");
const error_1 = require("../../../error");
const util_1 = require("util");
const expect_1 = require("../../../expect");
/**
 * The API session object, serves as the base for sessions and contains the fields that are required by
 * most API calls (hostname, port, credentials, etc).
 * @export
 * @abstract
 * @class AbstractSession
 */
class AbstractSession {
    /**
     * Creates an instance of AbstractSession.
     * @param {ISession} session: Session parameter object
     * @memberof AbstractSession
     */
    constructor(mISession) {
        this.mISession = mISession;
        this.mLog = logger_1.Logger.getImperativeLogger();
        mISession = this.buildSession(mISession);
    }
    /**
     * Obtain user name from a base 64 credential
     * @static
     * @param {string} auth - base 64 encoded credentials
     * @returns {string} - user name
     * @memberof AbstractSession
     */
    static getUsernameFromAuth(auth) {
        auth = auth.replace(AbstractSession.BASIC, "");
        const decoding = Buffer.from(auth, "base64").toString();
        return decoding.substring(0, decoding.lastIndexOf(":"));
    }
    /**
     * Obtain password from a base 64 credential
     * @static
     * @param {string} auth - base 64 encoded credentials
     * @returns {string} - password
     * @memberof AbstractSession
     */
    static getPasswordFromAuth(auth) {
        auth = auth.replace(AbstractSession.BASIC, "");
        const decoding = Buffer.from(auth, "base64").toString();
        return decoding.substring(decoding.lastIndexOf(":") + 1);
    }
    /**
     * Create base 64 encoded representation of user and password
     * @static
     * @param user - plain text user
     * @param password - plain text password
     * @returns {string} - base 64 encoded auth
     * @memberof AbstractSession
     */
    static getBase64Auth(user, password) {
        return Buffer.from(user + ":" + password).toString("base64");
    }
    /**
     * Method to parse the requested token type
     * @param {*} cookie - cookie object from http(s) response
     * @memberof AbstractSession
     */
    storeCookie(cookie) {
        const headerKeys = Object.keys(cookie);
        headerKeys.forEach((key) => {
            const auth = cookie[key];
            const authArr = auth.split(";");
            // see each field in the cookie, e/g. Path=/; Secure; HttpOnly; LtpaToken2=...
            authArr.forEach((element) => {
                // if we match requested token type, save it off for its length
                if (element.indexOf(this.mISession.tokenType) === 0) {
                    // parse off token value, minus LtpaToken2= (as an example)
                    this.ISession.tokenValue = element.substr(0, element.length);
                }
            });
        });
    }
    /**
     * Check that required fields are provided for basic auth requests
     * @private
     * @param {ISession} session: Session parameter object
     * @memberof AbstractSession
     */
    checkBasicAuth(session) {
        if (!util_1.isNullOrUndefined(session.user) && !util_1.isNullOrUndefined(session.password)) {
            // ok
        }
        else if (!util_1.isNullOrUndefined(session.base64EncodedAuth)) {
            // ok
        }
        else {
            throw new error_1.ImperativeError({ msg: "Must have user & password OR base64 encoded credentials" });
        }
    }
    /**
     * Builds an ISession so all required pieces are filled in
     * @private
     * @param {ISession} session - the fully populated session
     * @memberof AbstractSession
     */
    buildSession(session) {
        const populatedSession = session;
        // set protocol if not set
        if (util_1.isNullOrUndefined(populatedSession.protocol)) {
            populatedSession.protocol = AbstractSession.DEFAULT_PROTOCOL;
        }
        // set rejectUnauthorized
        if (util_1.isNullOrUndefined(populatedSession.rejectUnauthorized)) {
            populatedSession.rejectUnauthorized = AbstractSession.DEFAULT_REJECT_UNAUTHORIZED_SETTING;
        }
        // set strictSSL
        if (util_1.isNullOrUndefined(populatedSession.strictSSL)) {
            populatedSession.strictSSL = AbstractSession.DEFAULT_STRICT_SSL;
        }
        // set port if not set
        if (util_1.isNullOrUndefined(populatedSession.port)) {
            if (populatedSession.protocol === AbstractSession.HTTP_PROTOCOL) {
                populatedSession.port = AbstractSession.DEFAULT_HTTP_PORT;
            }
            else if (populatedSession.protocol === AbstractSession.HTTPS_PROTOCOL) {
                populatedSession.port = AbstractSession.DEFAULT_HTTPS_PORT;
            }
        }
        // set protocol if not set
        if (util_1.isNullOrUndefined(populatedSession.secureProtocol)) {
            populatedSession.secureProtocol = AbstractSession.DEFAULT_SECURE_PROTOCOL;
        }
        // set basePath if not set
        if (util_1.isNullOrUndefined(populatedSession.basePath)) {
            populatedSession.basePath = AbstractSession.DEFAULT_BASE_PATH;
        }
        // set type if not set
        if (util_1.isNullOrUndefined(populatedSession.type)) {
            populatedSession.type = AbstractSession.DEFAULT_TYPE;
        }
        // populatedSession.type = populatedSession.type.toLocaleLowerCase();
        expect_1.ImperativeExpect.keysToBeDefinedAndNonBlank(populatedSession, ["hostname"]);
        expect_1.ImperativeExpect.toBeOneOf(populatedSession.type, [AbstractSession.TYPE_NONE, AbstractSession.TYPE_BASIC, AbstractSession.TYPE_TOKEN]);
        expect_1.ImperativeExpect.toBeOneOf(populatedSession.protocol, [AbstractSession.HTTPS_PROTOCOL, AbstractSession.HTTP_PROTOCOL]);
        // if basic auth, must have user and password OR base 64 encoded credentials
        if (session.type === AbstractSession.TYPE_BASIC) {
            this.checkBasicAuth(session);
            expect_1.ImperativeExpect.keysToBeUndefined(populatedSession, ["tokenType", "tokenValue"]);
        }
        if (session.type === AbstractSession.TYPE_TOKEN) {
            expect_1.ImperativeExpect.keysToBeDefinedAndNonBlank(session, ["tokenType"], "You must provide a token type to use token authentication");
            // if you dont have a token, we need credentials to retrieve a token
            if (util_1.isNullOrUndefined(session.tokenValue)) {
                this.checkBasicAuth(session);
            }
        }
        // if basic auth
        if (populatedSession.type === AbstractSession.TYPE_BASIC || populatedSession.type === AbstractSession.TYPE_TOKEN) {
            // get base 64 encoded auth if not provided
            if (util_1.isNullOrUndefined(populatedSession.base64EncodedAuth)) {
                if (!util_1.isNullOrUndefined(populatedSession.user) && !util_1.isNullOrUndefined(populatedSession.user)) {
                    populatedSession.base64EncodedAuth = AbstractSession.getBase64Auth(populatedSession.user, populatedSession.password);
                }
            }
            else {
                if (util_1.isNullOrUndefined(populatedSession.user)) {
                    populatedSession.user = AbstractSession.getUsernameFromAuth(populatedSession.base64EncodedAuth);
                }
                if (util_1.isNullOrUndefined(populatedSession.password)) {
                    populatedSession.password = AbstractSession.getPasswordFromAuth(populatedSession.base64EncodedAuth);
                }
            }
        }
        return populatedSession;
    }
    /**
     * Obtain session info and defaults
     * @readonly
     * @type {ISession}
     * @memberof AbstractSession
     */
    get ISession() {
        return this.mISession;
    }
}
/**
 * Basic auth prefix
 * @static
 * @type {string}
 * @memberof AbstractSession
 */
AbstractSession.BASIC_PREFIX = "Basic ";
/**
 * http protocol id
 * @static
 * @memberof AbstractSession
 */
AbstractSession.HTTP_PROTOCOL = "http";
/**
 * https protocol id
 * @static
 * @memberof AbstractSession
 */
AbstractSession.HTTPS_PROTOCOL = "https";
/**
 * Default protocol
 * @static
 * @memberof AbstractSession
 */
AbstractSession.DEFAULT_PROTOCOL = AbstractSession.HTTPS_PROTOCOL;
/**
 * None type id
 * @static
 * @memberof AbstractSession
 */
AbstractSession.TYPE_NONE = "none";
/**
 * Basic type id
 * @static
 * @memberof AbstractSession
 */
AbstractSession.TYPE_BASIC = "basic";
/**
 * Token type id
 * @static
 * @memberof AbstractSession
 */
AbstractSession.TYPE_TOKEN = "token";
/**
 * Default session type
 * @static
 * @memberof AbstractSession
 */
AbstractSession.DEFAULT_TYPE = AbstractSession.TYPE_NONE;
/**
 * Default http port 80
 * @static
 * @memberof AbstractSession
 */
AbstractSession.DEFAULT_HTTP_PORT = 80;
/**
 * Default https port 443
 * @static
 * @memberof AbstractSession
 */
AbstractSession.DEFAULT_HTTPS_PORT = 443;
/**
 * Default https port
 * @static
 * @memberof AbstractSession
 */
AbstractSession.DEFAULT_PORT = AbstractSession.DEFAULT_HTTPS_PORT;
/**
 * Default base path.
 * Our empty string means that we do **not** use an API mediation layer
 * base path at the beginning of every resource URL.
 * @static
 * @memberof AbstractSession
 */
AbstractSession.DEFAULT_BASE_PATH = "";
/**
 * Default reject unauthorized
 * @static
 * @memberof AbstractSession
 */
AbstractSession.DEFAULT_REJECT_UNAUTHORIZED_SETTING = true;
/**
 * Default strict ssl setting
 * @static
 * @memberof AbstractSession
 */
AbstractSession.DEFAULT_STRICT_SSL = true;
/**
 * Default SSL method
 * @static
 * @memberof AbstractSession
 */
AbstractSession.DEFAULT_SECURE_PROTOCOL = "SSLv23_method";
/**
 * Regex to extract basic from base64 encoded auth
 * @static
 * @type {RegExp}
 * @memberof AbstractSession
 */
AbstractSession.BASIC = /^Basic/ig;
exports.AbstractSession = AbstractSession;
//# sourceMappingURL=AbstractSession.js.map