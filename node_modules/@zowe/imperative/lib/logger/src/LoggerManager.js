"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("../../console");
const fs_1 = require("fs");
/**
 * LoggerManager is a singleton class used to contain logger information.
 */
class LoggerManager {
    constructor() {
        this.mIsLoggerInit = false;
        this.mLogInMemory = false;
        this.mQueuedMessages = [];
        this.console = new console_1.Console();
        this.mMaxQueueSize = LoggerManager.DEFAULT_MAX_QUEUE_SIZE;
    }
    static get instance() {
        if (this.mInstance == null) {
            this.mInstance = new LoggerManager();
        }
        return this.mInstance;
    }
    /**
     * The following flag is used to monitor if the Logger.initLogger function
     * have been called to set the configuration of log4js.
     */
    get isLoggerInit() {
        return this.mIsLoggerInit;
    }
    set isLoggerInit(status) {
        this.mIsLoggerInit = status;
    }
    /**
     * The following flag is used to control if the log message should be store
     * in memory while log4js have yet to be configured.
     */
    get logInMemory() {
        return this.mLogInMemory;
    }
    set logInMemory(status) {
        this.mLogInMemory = status;
    }
    /**
     * The following value is used to control the max number of messages allowed
     * to be stored in memory at all time.
     */
    get maxQueueSize() {
        return this.mMaxQueueSize;
    }
    set maxQueueSize(size) {
        this.mMaxQueueSize = size;
    }
    /**
     * This function returned an array that contain all of the messages.
     */
    get QueuedMessages() {
        return this.mQueuedMessages;
    }
    /**
     * This function is responsible for gathering all of the input parameters and
     * store them in the message queue array.
     *
     * New messages are to be stored at the top of the array instead of the bottom.
     * This allow easy removing message from array while looping the array.
     * @param category - logger category
     * @param method - log method
     * @param message - log message
     */
    queueMessage(category, method, message) {
        if (this.logInMemory) {
            this.QueuedMessages.unshift({
                category,
                method,
                message
            });
            if (this.QueuedMessages.length > this.maxQueueSize) {
                this.QueuedMessages.pop();
            }
        }
        else {
            this.console.info(message);
        }
    }
    /**
     * Dump all of the log messages in memory to the specified file
     * @param file log file
     */
    dumpQueuedMessages(file) {
        if (this.QueuedMessages.length > 0) {
            this.console.debug(`Writing all logged messages in memory to ${file}`);
            this.QueuedMessages.slice().reverse().forEach((value, index) => {
                this.console[value.method](value.message);
                try {
                    fs_1.appendFileSync(file, `${value.message}\n`);
                }
                catch (error) {
                    /**
                     * For whatever reason causing logger to unable to append to the log file,
                     * log the error to console so user see and take appropriate action.
                     */
                    this.console.info(error);
                }
            });
        }
    }
}
LoggerManager.DEFAULT_MAX_QUEUE_SIZE = 10000;
LoggerManager.mInstance = null;
exports.LoggerManager = LoggerManager;
//# sourceMappingURL=LoggerManager.js.map