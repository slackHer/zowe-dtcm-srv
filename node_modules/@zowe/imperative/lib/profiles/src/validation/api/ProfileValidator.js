"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const logger_1 = require("../../../../logger");
const utilities_1 = require("../../../../utilities");
const operations_1 = require("../../../../operations");
const CliUtils_1 = require("../../../../utilities/src/CliUtils");
/**
 * API for going through the full validation test for a Brightside CLI profile
 * and producing validation report
 */
class ProfileValidator {
    /**
     * The command line option for printing the validation plan only
     */
    static get PRINT_PLAN_OPTION() {
        return {
            name: "print-plan-only", aliases: ["plan", "p"],
            description: "Instead of validating your profile, print out " +
                "a table of the tasks used for validation. This will explain the different services and " +
                "functionality that will be tested during profile validation.",
            type: "boolean"
        };
    }
    /**
     *  Produce a profile validation report for a specific profile
     * @param {IProfile} profile the profile to validate
     * @param {IProfileValidationPlan} plan - the profile validation testing plan
     * @param productDisplayName - the display name for your CLI
     * @returns {IPromiseWithProgress<IProfileValidationReport>} a promise of the validation report, with an additional field
     *                              that can be used to create a progress bar or track progress in another UI
     */
    static validate(profile, plan, productDisplayName) {
        const log = logger_1.Logger.getImperativeLogger();
        const progress = {
            stageName: operations_1.TaskStage.IN_PROGRESS,
            percentComplete: operations_1.TaskProgress.ZERO_PERCENT,
            statusMessage: "Preparing to validate profile"
        };
        const promise = new Promise((validationComplete) => {
            const report = {
                overallResult: "OK",
                taskResults: [],
                overallMessage: "Your profile is valid and ready for use with " +
                    productDisplayName,
                profile
            };
            log.debug("Validating profile with %d tasks", plan.tasks.length);
            let tasksCompleted = 0;
            let numTasksToComplete = 0;
            const countTasks = (task) => {
                numTasksToComplete++;
                if (!util_1.isNullOrUndefined(task.dependentTasks)) {
                    for (const dependent of task.dependentTasks) {
                        countTasks(dependent);
                    }
                }
            };
            for (const task of plan.tasks) {
                countTasks(task); // get the total number of tasks
            }
            if (numTasksToComplete === 0) {
                throw new Error("Validation plan has no tasks! If you want to validate a profile, " +
                    "you need at least one task in your plan.");
            }
            let tasksToRun = [].concat(plan.tasks);
            // define how tasks will be handled when we run them
            const runTask = () => {
                const currentTask = tasksToRun[0];
                tasksToRun = tasksToRun.slice(1); // take off the task we're working on now
                const skipDependentTask = (dependentTask, result) => {
                    // add a 'skipped task' result for each descendant dependent task
                    const skippedResult = {
                        taskName: dependentTask.name,
                        associatedEndpoints: dependentTask.associatedEndpoints,
                        outcome: "Warning",
                        resultDescription: utilities_1.TextUtils.formatMessage("Skipped due to '%s' getting a result of %s", currentTask.name, this.outcomeToString(result.outcome))
                    };
                    report.taskResults.push(skippedResult);
                    tasksCompleted++;
                    if (!util_1.isNullOrUndefined(dependentTask.dependentTasks)) {
                        for (const grandDependent of dependentTask.dependentTasks) {
                            skipDependentTask(grandDependent, result);
                        }
                    }
                };
                const taskFunction = currentTask.taskFunction;
                progress.percentComplete = (((tasksCompleted) / numTasksToComplete) * operations_1.TaskProgress.ONE_HUNDRED_PERCENT);
                progress.statusMessage = utilities_1.TextUtils.formatMessage("Checking '%s' (%d of %d)", currentTask.name, tasksCompleted + 1, numTasksToComplete);
                try {
                    taskFunction(profile, (result) => {
                        result.associatedEndpoints = currentTask.associatedEndpoints;
                        result.taskName = currentTask.name;
                        // task is complete, store off the results
                        tasksCompleted++;
                        report.taskResults.push(result);
                        log.debug("Profile validation task result: task name: %s, outcome %s, description %s, associated endpoints: %s", result.taskName, this.outcomeToString(result.outcome), result.resultDescription, (util_1.isNullOrUndefined(result.associatedEndpoints) ? "none" : result.associatedEndpoints.join(", ")));
                        // set the overall status of the validation based on this outcome
                        // only 100% success is considered a successful validation
                        if (result.outcome === "Warning" && report.overallResult === "OK") {
                            report.overallResult = "Warning";
                        }
                        else if (result.outcome === "Failed") {
                            // mark the validation failed if any task fails
                            report.overallResult = "Failed";
                        }
                        if (!util_1.isNullOrUndefined(currentTask.dependentTasks)) {
                            if (result.outcome === "Failed" || result.outcome === "Warning") {
                                log.warn("Parent task %s failed, skipping dependent tasks", currentTask.name);
                                for (const dependent of currentTask.dependentTasks) {
                                    skipDependentTask(dependent, result);
                                }
                            }
                            else {
                                // add the dependent tasks as the next tasks to execute
                                log.debug("Adding dependent tasks of %s to the lists of tasks to run", currentTask.name);
                                tasksToRun = currentTask.dependentTasks.concat(tasksToRun);
                            }
                        }
                        if (tasksCompleted < numTasksToComplete) {
                            // if there are more tasks, run the next one
                            runTask();
                        }
                        else {
                            log.info("All profile validation tasks have completed. The profile's validity: %s", this.outcomeToString(report.overallResult));
                            validationComplete(report);
                        }
                    });
                }
                /**
                 * Catch unexpected exceptions within the task function
                 */ catch (e) {
                    tasksCompleted++;
                    report.overallResult = "Failed";
                    log.error("Error during profile validation: %s\n%s", e.message, e.stack);
                    const result = {
                        outcome: "Failed",
                        resultDescription: "Encountered an unexpected exception: " + e.message,
                        associatedEndpoints: currentTask.associatedEndpoints,
                        taskName: currentTask.taskName
                    };
                    report.taskResults.push(result);
                    log.warn("Parent task %s failed, skipping dependent tasks", currentTask.name);
                    for (const dependent of currentTask.dependentTasks) {
                        skipDependentTask(dependent, result);
                    }
                    if (tasksCompleted < numTasksToComplete) {
                        // if there are more tasks, run the next one
                        runTask();
                    }
                    else {
                        log.info("All profile validation tasks have completed. The profile's validity: %s", this.outcomeToString(report.overallResult));
                        validationComplete(report);
                    }
                }
            };
            runTask();
        });
        promise.progress = progress;
        return promise;
    }
    /**
     * Get a printed/tabular version of your validation report
     * @param {IProfileValidationReport} report - your completed validation result
     * @param plan - the validation plan to use
     * @param productDisplayName - the display name for your CLI used in the final result text
     * @param primaryHighlightColor - color used to highlight headings and tables (used with chalk package)
     * @param profileName - the name of the profile that was validated
     * @param profileType - the type of the profile that was validated
     * @returns {string} - the formatted report
     */
    static getTextDisplayForReport(report, plan, productDisplayName, primaryHighlightColor, profileName, profileType) {
        const log = logger_1.Logger.getImperativeLogger();
        let text = "";
        let { failed, undetermined, succeeded } = this.countOutcomes(report);
        text += CliUtils_1.CliUtils.formatHelpHeader("Profile Summary", undefined, primaryHighlightColor) + "\n\n";
        const censoredProfile = logger_1.LoggerUtils.censorYargsArguments(report.profile);
        text += utilities_1.TextUtils.prettyJson(censoredProfile);
        text += CliUtils_1.CliUtils.formatHelpHeader("Profile Validation Results", undefined, primaryHighlightColor) + "\n\n";
        /**
         * Get a colored summary of the total numbers of failed, warning, and succeeded tests
         */
        if (failed === 0) {
            failed = utilities_1.TextUtils.chalk.gray(failed);
        }
        else {
            failed = utilities_1.TextUtils.chalk.red(failed);
        }
        if (undetermined === 0) {
            undetermined = utilities_1.TextUtils.chalk.gray(undetermined);
        }
        else {
            undetermined = utilities_1.TextUtils.chalk.yellow(undetermined);
        }
        if (succeeded === 0) {
            succeeded = utilities_1.TextUtils.chalk.gray(succeeded);
        }
        else {
            succeeded = utilities_1.TextUtils.chalk.green(succeeded);
        }
        const tableObject = report.taskResults.map((taskResult) => {
            let statusChar = "";
            if (taskResult.outcome === "OK") {
                statusChar = utilities_1.TextUtils.chalk.green("OK");
            }
            else if (taskResult.outcome === "Warning") {
                statusChar = utilities_1.TextUtils.chalk.yellow("?\nWarning");
            }
            else if (taskResult.outcome === "Failed") {
                statusChar = utilities_1.TextUtils.chalk.red("X\nFailed");
            }
            let description = taskResult.resultDescription;
            const maxDescriptionLength = 500;
            if (description.length > maxDescriptionLength) {
                description = description.substring(0, maxDescriptionLength) + "...(more info in log)";
                log.info("Truncated description from profile validation: %s", taskResult.resultDescription);
            }
            const result = {
                Task: taskResult.taskName,
                Status: statusChar,
                Description: description,
                Endpoint: taskResult.associatedEndpoints ? taskResult.associatedEndpoints.join(", ") : undefined
            };
            if (util_1.isNullOrUndefined(result.Endpoint)) {
                // this prevents the endpoint column from showing up
                // if there are no endpoints specified
                delete result.Endpoint;
            }
            return result;
        });
        text += utilities_1.TextUtils.getTable(tableObject, primaryHighlightColor, undefined, true, true, true) + "\n\n";
        text += utilities_1.TextUtils.wordWrap(utilities_1.TextUtils.formatMessage("Of %s tests, %s succeeded, %s failed, and %s had warnings or undetermined results.\n\n", report.taskResults.length, succeeded, failed, undetermined));
        if (report.overallResult === "OK") {
            text += utilities_1.TextUtils.chalk.green("   *~~ Perfect score! Wow! ~~*   ") + "\n\n";
        }
        let outcomeMessage = "";
        switch (report.overallResult) {
            case "OK":
                outcomeMessage = "is valid and ready for use with " + productDisplayName + ".\n All profile validation tests " +
                    "succeeded.";
                break;
            case "Failed":
                outcomeMessage = "will not function fully with " + productDisplayName + ".\nAt least one of the above " +
                    "tests failed. " + (plan.failureSuggestions ? "\n" + plan.failureSuggestions : "");
                break;
            case "Warning":
                outcomeMessage = "might not function properly with " + productDisplayName + ".\nAt least one of the above " +
                    "tests got ambiguous results. " + (plan.failureSuggestions ? "\n" + plan.failureSuggestions : "");
                break;
            default:
                log.warn("Unknown validation outcome in report for %s profile %s", profileType, profileName);
        }
        text += utilities_1.TextUtils.wordWrap(utilities_1.TextUtils.formatMessage("The %s profile named \"%s\" %s\n", profileType + "", profileName + "", outcomeMessage));
        return text;
    }
    /**
     * Get a printed/tabular version of your validation plan,
     * so that the user can see what steps the Brightside CLI will take to validate their profile
     * @param {IProfileValidationPlan} plan - the plan for profile validation
     * @param profile - the profile that would be validated - used only in this case to show a summary of the profile's contents
     * @param primaryHighlightColor - primary highlight color for use with chalk
     * @returns {string} - the formatted report
     */
    static getTextDisplayForPlan(plan, profile, primaryHighlightColor) {
        let text = "";
        text += CliUtils_1.CliUtils.formatHelpHeader("Profile Summary", undefined, primaryHighlightColor) + "\n\n";
        const censoredProfile = logger_1.LoggerUtils.censorYargsArguments(profile);
        text += utilities_1.TextUtils.prettyJson(censoredProfile);
        text += CliUtils_1.CliUtils.formatHelpHeader("Profile Validation Plan", undefined, primaryHighlightColor) + "\n\n";
        /**
         * Collapse the tree of task dependencies into a 1D array
         * so that we can display it in the table
         */
        const allTasks = [];
        const addTasks = (task) => {
            allTasks.push(task);
            if (!util_1.isNullOrUndefined(task.dependentTasks)) {
                for (const dependent of task.dependentTasks) {
                    addTasks(dependent);
                }
            }
        };
        for (const task of plan.tasks) {
            addTasks(task);
        }
        const tableObject = allTasks.map((task) => {
            const result = {
                Task: task.name,
                Description: task.description,
                Endpoints: task.associatedEndpoints ? task.associatedEndpoints.join(", ") : undefined
            };
            if (result.Endpoints == null) {
                delete result.Endpoints;
            }
            return result;
        });
        text += utilities_1.TextUtils.getTable(tableObject, primaryHighlightColor, undefined, true, true) + "\n\n";
        return text;
    }
    /**
     * Get a more readable version of the outcome
     * @param {VALIDATION_OUTCOME} outcome - the outcome to convert to readable version
     * @returns {string} - full version of the outcome
     */
    static outcomeToString(outcome) {
        if (outcome === "OK") {
            return "Succeeded";
        }
        else if (outcome === "Warning") {
            return "Warning";
        }
        else if (outcome === "Failed") {
            return "Failed";
        }
    }
    /**
     * Get the total number of each type of profile validation outcome
     * @param {IProfileValidationReport} report - the report from which
     * @returns {{succeeded: number, undetermined: number, failed: number}} - total count
     *                                   of what has succeeded, undetermined, failed
     */
    static countOutcomes(report) {
        const log = logger_1.Logger.getImperativeLogger();
        const result = { succeeded: 0, undetermined: 0, failed: 0 };
        for (const task of report.taskResults) {
            switch (task.outcome) {
                case "OK":
                    result.succeeded++;
                    break;
                case "Warning":
                    result.undetermined++;
                    break;
                case "Failed":
                    result.failed++;
                    break;
                default:
                    log.warn("Unknown validation outcome for %s profile %s", report.profile.type, report.profile.name);
            }
        }
        return result;
    }
}
/**
 * The key used to access the filename for the type containing the profile
 * validation plan object. On your profile validation command definition,
 * specify the filename in   .customize[CUSTOMIZE_PLAN_KEY]
 * @type {string}
 */
ProfileValidator.CUSTOMIZE_PLAN_KEY = "validationPlanModule";
exports.ProfileValidator = ProfileValidator;
//# sourceMappingURL=ProfileValidator.js.map