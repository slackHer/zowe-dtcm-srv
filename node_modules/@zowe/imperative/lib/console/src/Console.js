"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const utilities_1 = require("../../utilities");
const moment = require("moment");
const util_1 = require("util");
const error_1 = require("../../error");
class Console {
    constructor(mLevel = Console.LEVEL_DEFAULT) {
        this.mLevel = mLevel;
        this.mPrefix = true;
        this.mColor = true;
        this.mLevel = mLevel.toLocaleLowerCase();
        this.mIsOn = true;
        Console.validateLevel(this.mLevel);
    }
    static getConsole(category) {
        return new Console();
    }
    static isValidLevel(level) {
        return Console.LEVELS.indexOf(level) < 0 ? false : true;
    }
    static validateLevel(level) {
        if (!Console.isValidLevel(level)) {
            throw new error_1.ImperativeError({
                msg: "Invalid level specified",
            });
        }
    }
    addContext(key, value) {
        // do nothing
    }
    removeContext(key) {
        // do nothing
    }
    clearContext() {
        // do nothing
    }
    isLevelEnabled() {
        return false;
    }
    isTraceEnabled() {
        return Console.LEVELS.indexOf("trace") >= Console.LEVELS.indexOf(this.level) ? true : false;
    }
    isDebugEnabled() {
        return Console.LEVELS.indexOf("debug") >= Console.LEVELS.indexOf(this.level) ? true : false;
    }
    isInfoEnabled() {
        return Console.LEVELS.indexOf("info") >= Console.LEVELS.indexOf(this.level) ? true : false;
    }
    isWarnEnabled() {
        return Console.LEVELS.indexOf("warn") >= Console.LEVELS.indexOf(this.level) ? true : false;
    }
    isErrorEnabled() {
        return Console.LEVELS.indexOf("error") >= Console.LEVELS.indexOf(this.level) ? true : false;
    }
    isFatalEnabled() {
        return Console.LEVELS.indexOf("fatal") >= Console.LEVELS.indexOf(this.level) ? true : false;
    }
    isFormatEnabled() {
        return true;
    }
    info(message, ...args) {
        if (!this.isInfoEnabled()) {
            return;
        }
        let adjustedMessage = message;
        if (this.prefix) {
            adjustedMessage = this.buildPrefix("INFO") + message;
        }
        if (this.color) {
            adjustedMessage = utilities_1.TextUtils.chalk.grey(adjustedMessage);
        }
        return this.writeStdout(adjustedMessage, args);
    }
    trace(message, ...args) {
        if (!this.isTraceEnabled()) {
            return;
        }
        let adjustedMessage = message;
        if (this.prefix) {
            adjustedMessage = this.buildPrefix("TRACE") + message;
        }
        if (this.color) {
            adjustedMessage = utilities_1.TextUtils.chalk.cyan(adjustedMessage);
        }
        return this.writeStdout(adjustedMessage, args);
    }
    debug(message, ...args) {
        if (!this.isDebugEnabled()) {
            return;
        }
        let adjustedMessage = message;
        if (this.prefix) {
            adjustedMessage = this.buildPrefix("DEBUG") + message;
        }
        if (this.color) {
            adjustedMessage = utilities_1.TextUtils.chalk.blue(adjustedMessage);
        }
        return this.writeStdout(adjustedMessage, args);
    }
    warn(message, ...args) {
        if (!this.isWarnEnabled()) {
            return;
        }
        let adjustedMessage = message;
        if (this.prefix) {
            adjustedMessage = this.buildPrefix("WARN") + message;
        }
        if (this.color) {
            adjustedMessage = utilities_1.TextUtils.chalk.yellow(adjustedMessage);
        }
        return this.writeStderr(adjustedMessage, args);
    }
    error(message, ...args) {
        if (!this.isErrorEnabled()) {
            return;
        }
        let adjustedMessage = message;
        if (this.prefix) {
            adjustedMessage = this.buildPrefix("ERROR") + message;
        }
        if (this.color) {
            adjustedMessage = utilities_1.TextUtils.chalk.red(adjustedMessage);
        }
        return this.writeStderr(adjustedMessage, args);
    }
    fatal(message, ...args) {
        if (!this.isFatalEnabled()) {
            return;
        }
        let adjustedMessage = message;
        if (this.prefix) {
            adjustedMessage = this.buildPrefix("FATAL") + message;
        }
        if (this.color) {
            adjustedMessage = utilities_1.TextUtils.chalk.magenta(adjustedMessage);
        }
        return this.writeStderr(adjustedMessage, args);
    }
    writeStderr(message, ...args) {
        const data = this.format(message, args);
        if (this.on) {
            process.stderr.write(this.format(message, args));
        }
        return data;
    }
    writeStdout(message, ...args) {
        const data = this.format(message, args);
        if (this.on) {
            process.stdout.write(data);
        }
        return data;
    }
    format(data, ...args) {
        let formatted = data;
        // TODO(Kelosky): this is not ideal, but works for simple cases of
        // .debug(%s, "sub string").
        if (this.isFormatEnabled() && !util_1.isNullOrUndefined(args) && args.length > 0) {
            let defined = false;
            args.forEach((arg) => {
                arg.forEach((ntry) => {
                    if (ntry.length > 0) {
                        defined = true;
                    }
                });
            });
            // if every argument is undefined, dont format it
            if (defined) {
                formatted = util_1.format(data, args);
            }
        }
        return formatted + "\n";
    }
    buildPrefix(type) {
        return "[" + moment().format("YYYY/MM/DD HH:MM:SS") + "]" + " " + "[" + type + "]" + " ";
    }
    set level(level) {
        level = level.toLowerCase();
        Console.validateLevel(level);
        this.mLevel = level;
    }
    get level() {
        return this.mLevel;
    }
    set prefix(isEnabled) {
        this.mPrefix = isEnabled;
    }
    get prefix() {
        return this.mPrefix;
    }
    set color(isEnabled) {
        this.mColor = isEnabled;
    }
    get color() {
        return this.mColor;
    }
    set on(isOn) {
        this.mIsOn = isOn;
    }
    get on() {
        return this.mIsOn;
    }
}
Console.LEVELS = ["trace", "debug", "info", "warn", "error", "fatal"];
Console.LEVEL_DEFAULT = "debug";
exports.Console = Console;
//# sourceMappingURL=Console.js.map