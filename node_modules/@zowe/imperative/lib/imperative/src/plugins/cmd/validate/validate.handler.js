"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utilities_1 = require("../../../../../utilities");
const PluginIssues_1 = require("../../utilities/PluginIssues");
/**
 * The validate command handler for the cli plugin validate command.
 *
 * @see {validateDefinition}
 */
class ValidateHandler {
    constructor() {
        /**
         * A class with recorded issues for each plugin for which problems were detected.
         *
         * @private
         * @type {IPluginIssues}
         */
        this.pluginIssues = PluginIssues_1.PluginIssues.instance;
    }
    // __________________________________________________________________________
    /**
     * Process the command and input.
     *
     * @param {IHandlerParameters} params - Parameters supplied by yargs
     *
     * @param {string[]} [params.arguments.plugin] - The name of
     *        a plugin to validate. If omitted all installed plugins
     *        will be validated.
     *
     * @returns {Promise<ICommandResponse>} The command response
     *
     * @throws {ImperativeError}
     */
    process(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let pluginName = null;
            const installedPlugins = this.pluginIssues.getInstalledPlugins();
            if (params.arguments.plugin == null ||
                params.arguments.plugin.length === 0 ||
                params.arguments.plugin === "") {
                if (Object.keys(installedPlugins).length === 0) {
                    params.response.console.log("No plugins have been installed into your CLI application.");
                }
                else {
                    // loop through each plugin installed in our plugins file
                    for (pluginName in installedPlugins) {
                        if (this.pluginIssues.getInstalledPlugins().hasOwnProperty(pluginName)) {
                            this.displayPluginIssues(pluginName, params.response);
                        }
                    }
                }
            }
            else {
                // is the specified plugin installed?
                pluginName = params.arguments.plugin;
                if (!installedPlugins.hasOwnProperty(pluginName)) {
                    params.response.console.log(utilities_1.TextUtils.chalk.red("The specified plugin '" + pluginName +
                        "' has not been installed into your CLI application."));
                }
                else {
                    this.displayPluginIssues(pluginName, params.response);
                }
            }
        });
    }
    // __________________________________________________________________________
    /**
     * Display the issues assocated with the specified plugin.
     *
     * @param {string} pluginName - The name of the plugin.
     *
     * @param {IHandlerResponseApi} cmdResponse - Used to supply the response from the command.
     */
    displayPluginIssues(pluginName, cmdResponse) {
        // display any plugin issues
        let valResultsMsg = "\n_____ " + "Validation results for plugin '" +
            pluginName + "' _____\n";
        const issueListForPlugin = this.pluginIssues.getIssueListForPlugin(pluginName);
        if (issueListForPlugin.length === 0) {
            valResultsMsg += "This plugin was successfully validated. Enjoy the plugin.";
            cmdResponse.console.log(valResultsMsg);
        }
        else {
            const setOfIssueSevs = [];
            for (const nextIssue of issueListForPlugin) {
                valResultsMsg += "\n*** " + nextIssue.issueSev + ": " + nextIssue.issueText + "\n";
                if (!setOfIssueSevs.includes(nextIssue.issueSev)) {
                    setOfIssueSevs.push(nextIssue.issueSev);
                }
            }
            valResultsMsg += "\n";
            let msgColor = "yellow";
            if (setOfIssueSevs.includes(PluginIssues_1.IssueSeverity.CFG_ERROR)) {
                msgColor = "red";
                valResultsMsg += "This plugin has configuration errors. No component of the plugin will be available.";
            }
            else {
                if (setOfIssueSevs.includes(PluginIssues_1.IssueSeverity.CMD_ERROR)) {
                    msgColor = "red";
                    valResultsMsg += "This plugin has command errors. No plugin commands will be available.\n";
                }
                if (setOfIssueSevs.includes(PluginIssues_1.IssueSeverity.OVER_ERROR)) {
                    msgColor = "red";
                    valResultsMsg += "This plugin has override errors. This plugin will not override a framework component.";
                }
            }
            // if we had no errors, only warnings are left
            if (msgColor === "yellow") {
                valResultsMsg += "This plugin has warnings, but its commands and framework overrides will still be available.";
            }
            cmdResponse.console.log(utilities_1.TextUtils.chalk[msgColor](valResultsMsg));
        }
    }
}
exports.default = ValidateHandler;
//# sourceMappingURL=validate.handler.js.map