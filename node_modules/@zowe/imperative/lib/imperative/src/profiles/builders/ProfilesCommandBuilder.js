"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const profiles_1 = require("../../../../profiles");
/**
 * Abstract class for generating profile-related commands
 */
class ProfilesCommandBuilder {
    /**
     * Construct the builder based on the schema.
     * @param mProfileType - the name of the profile type e.g. banana
     * @param {Logger} mLogger - logger instance to use for the builder class
     * @param {IProfileSchema} mProfileConfig: The schema that describes the profile
     */
    constructor(mProfileType, mLogger, mProfileConfig) {
        this.mProfileType = mProfileType;
        this.mLogger = mLogger;
        this.mProfileConfig = mProfileConfig;
        this.mSchema = mProfileConfig.schema;
        if (util_1.isNullOrUndefined(this.mSchema)) {
            throw new Error(`Profile Builder Error: No profile schema was supplied.`);
        }
    }
    /**
     * Only constructs the "group" command segment for the document. Use this if the command definition
     * document already includes a "create" verb.
     * @return {ICommandDefinition}
     */
    build() {
        return this.buildProfileSegmentFromSchema();
    }
    /**
     * Construct the operands from the Bright Profile Schema.
     * @param {any} properties: The properties set to iterate over looking for operands to add
     * @param {ICommandOptionDefinition[]} options: The final option definitions to add.
     * @return {ICommandOptionDefinition[]}: The set of returned option definitions
     */
    buildOptionsFromProfileSchema(properties, options) {
        for (const propName of Object.keys(properties)) {
            // helper to recursively add any nested option definitions
            const findAndAddOptions = (propertiesObject, propertyName) => {
                const field = propertiesObject[propertyName];
                if (!util_1.isNullOrUndefined(field.optionDefinition)) {
                    options.push(field.optionDefinition);
                }
                if (!util_1.isNullOrUndefined(field.optionDefinitions)) {
                    options = options.concat(field.optionDefinitions);
                }
                if (field.properties != null) {
                    for (const nestedProperty of Object.keys(field.properties)) {
                        findAndAddOptions(field.properties, nestedProperty);
                    }
                }
            };
            findAndAddOptions(properties, propName);
        }
        if (!util_1.isNullOrUndefined(this.mProfileConfig.dependencies)) {
            for (const dependency of this.mProfileConfig.dependencies) {
                const description = dependency.description ||
                    "The name of a " + dependency.type + " profile to associate with this profile.";
                const dependencyOption = {
                    name: profiles_1.ProfileUtils.getProfileOption(dependency.type),
                    aliases: [profiles_1.ProfileUtils.getProfileOptionAlias(dependency.type)],
                    type: "string",
                    description,
                    required: dependency.required
                };
                options.push(dependencyOption);
            }
        }
        return options;
    }
}
exports.ProfilesCommandBuilder = ProfilesCommandBuilder;
//# sourceMappingURL=ProfilesCommandBuilder.js.map