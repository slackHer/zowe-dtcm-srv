"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const error_1 = require("../../../../error");
const index_1 = require("../../../index");
const profiles_1 = require("../../../../profiles");
const logger_1 = require("../../../../logger");
const utilities_1 = require("../../../../utilities");
/**
 * Generic handler for validating a profile and printing a report in response
 */
class ValidateProfileHandler {
    constructor() {
        /**
         * Get an instance of the imperative logger.
         * @private
         * @type {Logger}
         * @memberof ValidateProfileHandler
         */
        this.mLogger = index_1.Imperative.api.imperativeLogger;
    }
    process(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const profileType = params.definition.customize[profiles_1.ProfilesConstants.PROFILES_COMMAND_TYPE_KEY];
            const manager = index_1.Imperative.api.profileManager(profileType);
            let profileName = manager.getDefaultProfileName();
            // if the user specified a specific profile, we can determine the name of the profile from that
            if (params.arguments.profileName != null) {
                profileName = params.arguments.profileName;
            }
            const profileToValidate = (yield manager.load({ failNotFound: true, name: profileName })).profile;
            let plan;
            try {
                // load the definition of the plan from the specified file path
                // this will return the class definition of the plan
                const planModule = index_1.Imperative.getProfileConfiguration(profileType).validationPlanModule;
                plan = require(planModule);
                // instantiate the plan object
                plan = new plan();
            }
            catch (e) {
                const planLoadErr = {
                    msg: "An error was encountered trying to load the plan to validate the Brightside profile.",
                    additionalDetails: e.message,
                    causeErrors: e
                };
                throw new error_1.ImperativeError(planLoadErr);
            }
            // if the user just requested that we print the plan rather than actually validate the profile
            if (params.arguments[profiles_1.ProfileValidator.PRINT_PLAN_OPTION.name]) {
                logger_1.Logger.getImperativeLogger().debug("Printed plan for profile validation requested");
                params.response.console.log(Buffer.from(profiles_1.ProfileValidator.getTextDisplayForPlan(plan, profileToValidate, utilities_1.ImperativeConfig.instance.loadedConfig.primaryTextColor)));
                const cleanTaskForJSONOutput = (task) => {
                    delete task.taskFunction;
                    if (!util_1.isNullOrUndefined(task.dependentTasks)) {
                        for (const dependent of task.dependentTasks) {
                            cleanTaskForJSONOutput(dependent);
                        }
                    }
                };
                // add the object version of the plan to the JSON response, without the task functions
                // since they can't be printed
                for (const task of plan.tasks) {
                    cleanTaskForJSONOutput(task);
                }
                params.response.data.setObj(plan);
                return;
            }
            let report;
            try {
                const promise = profiles_1.ProfileValidator.validate(profileToValidate, plan, utilities_1.ImperativeConfig.instance.loadedConfig.productDisplayName);
                params.response.progress.startBar({ task: promise.progress });
                report = yield promise;
                params.response.data.setObj(report);
                const reportText = Buffer.from(profiles_1.ProfileValidator.getTextDisplayForReport(report, plan, utilities_1.ImperativeConfig.instance.loadedConfig.productDisplayName, utilities_1.ImperativeConfig.instance.loadedConfig.primaryTextColor, profileName, profileType));
                params.response.console.log(reportText);
            }
            catch (validateError) {
                const unexpectedError = {
                    msg: "Encountered an unexpected exception " +
                        "while validating your profile. ",
                    additionalDetails: validateError.message,
                    causeErrors: validateError
                };
                params.response.console.error("Failed to validate profile due to unexpected exception");
                throw new error_1.ImperativeError(unexpectedError);
            }
            if (report.overallResult !== "OK") {
                throw new error_1.ImperativeError({ msg: "The profile validation was not successful" });
            }
        });
    }
}
exports.default = ValidateProfileHandler;
//# sourceMappingURL=ValidateProfileHandler.js.map