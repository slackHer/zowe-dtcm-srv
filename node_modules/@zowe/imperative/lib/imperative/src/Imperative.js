"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Main class of the Imperative framework, returned when you
 * require("@zowe/imperative") e.g. const imperative =  require("@zowe/imperative");
 */
const perf_timing_1 = require("@zowe/perf-timing");
const logger_1 = require("../../logger");
const ConfigurationLoader_1 = require("./ConfigurationLoader");
const ConfigurationValidator_1 = require("./ConfigurationValidator");
const util_1 = require("util");
const ImperativeApi_1 = require("./api/ImperativeApi");
const constants_1 = require("../../constants");
const utilities_1 = require("../../utilities");
const LoggingConfigurer_1 = require("./LoggingConfigurer");
const error_1 = require("../../error");
const PluginManagementFacility_1 = require("./plugins/PluginManagementFacility");
const ConfigManagementFacility_1 = require("./config/ConfigManagementFacility");
const cmd_1 = require("../../cmd");
const profiles_1 = require("../../profiles");
const CompleteProfilesGroupBuilder_1 = require("./profiles/builders/CompleteProfilesGroupBuilder");
const ImperativeHelpGeneratorFactory_1 = require("./help/ImperativeHelpGeneratorFactory");
const OverridesLoader_1 = require("./OverridesLoader");
const ImperativeProfileManagerFactory_1 = require("./profiles/ImperativeProfileManagerFactory");
const DefinitionTreeResolver_1 = require("./DefinitionTreeResolver");
const EnvironmentalVariableSettings_1 = require("./env/EnvironmentalVariableSettings");
const settings_1 = require("../../settings");
const path_1 = require("path");
const console_1 = require("../../console");
// Bootstrap the performance tools
if (perf_timing_1.PerfTiming.isEnabled) {
    // These are expensive operations so imperative should
    // only do it when performance is enabled.
    const Module = require("module");
    // Store the reference to the original require.
    const originalRequire = Module.prototype.require;
    // Timerify a wrapper named function so we can be sure that not just
    // any anonymous function gets checked.
    Module.prototype.require = perf_timing_1.PerfTiming.api.watch(function NodeModuleLoader() {
        return originalRequire.apply(this, arguments);
    });
}
class Imperative {
    /**
     *  Retrieve the root command name.
     *  @example
     *  For example, in "banana a b --c", banana is the root command name.
     *  @returns {string} - root command name
     */
    static get rootCommandName() {
        return this.mRootCommandName;
    }
    /**
     *  Retrieve the command line.
     *  @example
     *  For example, banana a b --c", is the command line.
     *  @returns {string} - command line
     */
    static get commandLine() {
        return this.mCommandLine;
    }
    /**
     * Get the complete full command tree
     * @returns {ICommandDefinition}
     */
    static get fullCommandTree() {
        return this.mFullCommandTree;
    }
    /**
     * Initialize the configuration for your CLI.
     * Wipes out any existing config that has already been set.
     *
     * @param {IImperativeConfig} [config] Configuration for Imperative provided by your application.
     *                                     If this parameter is not set, we will look in the closest
     *                                     package.json up the directory tree from the main entry
     *                                     point of your cli.
     *
     *                                     package.imperative.configurationModule should point to the
     *                                     compiled module that exports the configuration.
     *
     * @returns {Promise<void>} A promise indicating that we are done here.
     */
    static init(config) {
        return new Promise((initializationComplete, initializationFailed) => __awaiter(this, void 0, void 0, function* () {
            try {
                const timingApi = perf_timing_1.PerfTiming.api;
                if (perf_timing_1.PerfTiming.isEnabled) {
                    // Marks point START
                    timingApi.mark("START_IMP_INIT");
                }
                /**
                 * Config Logger Manager to enable log messages in memory prior to logger init.
                 */
                logger_1.Logger.setLogInMemory(true);
                /**
                 * Identify caller's location on the system
                 */
                utilities_1.ImperativeConfig.instance.callerLocation = process.mainModule.filename;
                /**
                 * Load callers configuration, validate, and save
                 */
                config = ConfigurationLoader_1.ConfigurationLoader.load(config, utilities_1.ImperativeConfig.instance.callerPackageJson, utilities_1.ImperativeConfig.instance.getCallerFile);
                ConfigurationValidator_1.ConfigurationValidator.validate(config);
                utilities_1.ImperativeConfig.instance.loadedConfig = config;
                // Initialize our settings file
                this.initAppSettings();
                /**
                 * Get the command name from the package bin.
                 * If no command name exists, we will instead use the file name invoked
                 * and log a debug warning.
                 */
                if (!util_1.isNullOrUndefined(utilities_1.ImperativeConfig.instance.findPackageBinName())) {
                    this.mRootCommandName = utilities_1.ImperativeConfig.instance.findPackageBinName();
                }
                else {
                    this.mRootCommandName = utilities_1.ImperativeConfig.instance.callerLocation;
                    this.log.debug("WARNING: No \"bin\" configuration was found in your package.json," +
                        " or your package.json could not be found. " +
                        "Defaulting command name to filepath instead.");
                }
                utilities_1.ImperativeConfig.instance.rootCommandName = this.mRootCommandName;
                // If config group is enabled add config commands
                if (config.allowConfigGroup) {
                    ConfigManagementFacility_1.ConfigManagementFacility.instance.init();
                }
                // If plugins are allowed, enable core plugins commands
                if (config.allowPlugins) {
                    PluginManagementFacility_1.PluginManagementFacility.instance.init();
                    // load the configuration of every installed plugin for later processing
                    PluginManagementFacility_1.PluginManagementFacility.instance.loadAllPluginCfgProps();
                    // Override the config object with things loaded from plugins
                    Object.assign(utilities_1.ImperativeConfig.instance.loadedConfig.overrides, PluginManagementFacility_1.PluginManagementFacility.instance.pluginOverrides);
                }
                /**
                 * Once we have a complete representation of the config object, we should be able to
                 * use that and populate all required categories and expose them on our API object
                 * so that an app using imperative can write to the imperative log, its own log, or
                 * even a plug-in log.
                 *
                 * Any other initialization added to this routine should occur after logging has been initialized.
                 */
                this.initLogging();
                /**
                 * Now we should apply any overrides to default Imperative functionality. This is where CLI
                 * developers are able to really start customizing Imperative and how it operates internally.
                 */
                yield OverridesLoader_1.OverridesLoader.load(utilities_1.ImperativeConfig.instance.loadedConfig, utilities_1.ImperativeConfig.instance.callerPackageJson);
                /**
                 * Build API object
                 */
                this.mApi = this.constructApiObject();
                /**
                 * Build the help generator factory - requires the root command name and the loaded configuration document
                 */
                this.mHelpGeneratorFactory = new ImperativeHelpGeneratorFactory_1.ImperativeHelpGeneratorFactory(this.rootCommandName, utilities_1.ImperativeConfig.instance.loadedConfig);
                // resolve command module globs, forming the root of the CLI command tree
                this.log.info(`Loaded and validated config for '${config.name}'. Config details at trace level of logging.`);
                this.log.trace(`The config object for '${config.name}' is:\n` +
                    JSON.stringify(config, null, 2));
                const resolvedHostCliCmdTree = this.getResolvedCmdTree(config);
                // If plugins are allowed, add plugins' commands and profiles to the CLI command tree
                if (config.allowPlugins) {
                    PluginManagementFacility_1.PluginManagementFacility.instance.addAllPluginsToHostCli(resolvedHostCliCmdTree);
                    this.log.info("Plugins added to the CLI command tree.");
                }
                // final preparation of the command tree
                const preparedHostCliCmdTree = this.getPreparedCmdTree(resolvedHostCliCmdTree);
                /**
                 * Initialize the profile environment
                 */
                this.initProfiles(config);
                /**
                 * Define all known commands
                 */
                this.log.info("Inherited traits applied to CLI command tree children. " +
                    "Cmd tree details at trace level of logging.");
                this.log.trace("The CLI command tree before being defined to yargs: " +
                    JSON.stringify(preparedHostCliCmdTree, null, 2));
                this.defineCommands(preparedHostCliCmdTree);
                /**
                 * Notify caller initialization is complete
                 */
                initializationComplete();
                if (perf_timing_1.PerfTiming.isEnabled) {
                    // Marks point END
                    timingApi.mark("END_IMP_INIT");
                    timingApi.measure("Imperative.init()", "START_IMP_INIT", "END_IMP_INIT");
                }
            }
            catch (error) {
                const imperativeLogger = logger_1.Logger.getImperativeLogger();
                imperativeLogger.fatal(require("util").inspect(error));
                const os = require("os");
                imperativeLogger.fatal("Diagnostic information:\n" +
                    "Platform: '%s', Architecture: '%s', Process.argv: '%s'\n" +
                    "Node versions: '%s'" +
                    "Environmental variables: '%s'", os.platform(), os.arch(), process.argv.join(" "), JSON.stringify(process.versions, null, 2), JSON.stringify(process.env, null, 2));
                logger_1.Logger.writeInMemoryMessages(Imperative.DEFAULT_DEBUG_FILE);
                if (error.report) {
                    const { writeFileSync } = require("fs");
                    writeFileSync(Imperative.DEFAULT_DEBUG_FILE, error.report);
                }
                initializationFailed(error instanceof error_1.ImperativeError ?
                    error :
                    new error_1.ImperativeError({
                        msg: "UNEXPECTED ERROR ENCOUNTERED",
                        causeErrors: error
                    }));
            }
        }));
    }
    /**
     * Returns the default console object to be used for messaging for
     * imperative fails to initialize or to be used before logging
     * is initialized.
     * @return {Logger}: an instance of the default console object
     */
    static get console() {
        return this.constructConsoleApi();
    }
    /**
     * Parse command line arguments and issue the user's specified command
     * @returns {Imperative} this, for chaining syntax
     */
    static parse() {
        const timingApi = perf_timing_1.PerfTiming.api;
        if (perf_timing_1.PerfTiming.isEnabled) {
            // Marks point START
            timingApi.mark("START_IMP_PARSE");
        }
        Imperative.yargs.argv; // tslint:disable-line
        if (perf_timing_1.PerfTiming.isEnabled) {
            // Marks point END
            timingApi.mark("END_IMP_PARSE");
            timingApi.measure("Imperative.init()", "START_IMP_PARSE", "END_IMP_PARSE");
        }
        return this;
    }
    /**
     *
     * @param {string} type the profile type to search for configuration for
     * @returns {IImperativeProfileConfig | undefined}  The profile configuration if found, otherwise, undefined.
     */
    static getProfileConfiguration(type) {
        const profileConfigs = utilities_1.ImperativeConfig.instance.loadedConfig.profiles;
        if (util_1.isNullOrUndefined(profileConfigs) || profileConfigs.length === 0) {
            return undefined;
        }
        let foundConfig;
        for (const profile of profileConfigs) {
            if (profile.type === type) {
                foundConfig = profile;
            }
        }
        return foundConfig;
    }
    /**
     * Get the configured help generator for your CLI. If you have not specified a custom generator,
     * the DefaultHelpGenerator will be used.
     * You probably won't need to call this from your CLI, but it is used internally.
     * @returns {IHelpGenerator} - The help generator for the command
     * @param {IHelpGeneratorParms} parms - parameters to the help generator including command definition
     */
    static getHelpGenerator(parms) {
        return this.mHelpGeneratorFactory.getHelpGenerator(parms);
    }
    /**
     * Returns the imperative API object containing various framework API methods for usage in your CLI implemenation.
     * @return {ImperativeApi}: The api object.
     */
    static get api() {
        if (util_1.isNullOrUndefined(this.mApi)) {
            throw new error_1.ImperativeError({
                msg: "Imperative API object does not exist.  The Imperative.init() promise " +
                    "must be fullfilled before the API object can be accessed.  For issuing messages " +
                    "without the API object, use Imperative.console.",
            }, {
                logger: Imperative.console,
            });
        }
        return this.mApi;
    }
    /**
     * Highlight text with your configured (or default) primary color
     * @param {string} text - the text to highlight
     * @returns {string} - the highlighted text
     */
    static highlightWithPrimaryColor(text) {
        return utilities_1.TextUtils.chalk[utilities_1.ImperativeConfig.instance.loadedConfig.primaryTextColor](text);
    }
    /**
     * Get the configured environmental variable prefix for the user's CLI
     * @returns {string} - the configured or default prefix for environmental variables for use in the environmental variable service
     */
    static get envVariablePrefix() {
        return utilities_1.ImperativeConfig.instance.loadedConfig.envVariablePrefix == null ? utilities_1.ImperativeConfig.instance.loadedConfig.name :
            utilities_1.ImperativeConfig.instance.loadedConfig.envVariablePrefix;
    }
    /**
     * Highlight text with your configured (or default) secondary color
     * @param {string} text - the text to highlight
     * @returns {string} - the highlighted text
     */
    static highlightWithSecondaryColor(text) {
        return utilities_1.TextUtils.chalk[utilities_1.ImperativeConfig.instance.loadedConfig.secondaryTextColor](text);
    }
    /**
     * Get log instance
     */
    static get log() {
        return logger_1.Logger.getImperativeLogger();
    }
    /**
     * Load the correct {@link AppSettings} instance from values located in the
     * cli home folder.
     */
    static initAppSettings() {
        const cliSettingsRoot = path_1.join(utilities_1.ImperativeConfig.instance.cliHome, "settings");
        const cliSettingsFile = path_1.join(cliSettingsRoot, "imperative.json");
        const defaultSettings = {
            overrides: {
                CredentialManager: false
            }
        };
        settings_1.AppSettings.initialize(cliSettingsFile, defaultSettings);
    }
    /**
     * Init log object such that subsequent calls to the Logger.getImperativeLogger() (or
     * other similar calls), will contain all necessary categories for logging.
     *
     * TODO(Kelosky): handle level setting via global config (trace enabling and such)
     */
    static initLogging() {
        let message;
        /**
         * Build logging config from imperative config
         */
        const loggingConfig = LoggingConfigurer_1.LoggingConfigurer.configureLogger(utilities_1.ImperativeConfig.instance.cliHome, utilities_1.ImperativeConfig.instance.loadedConfig);
        /**
         * Set log levels from environmental variable settings
         */
        const envSettings = EnvironmentalVariableSettings_1.EnvironmentalVariableSettings.read(this.envVariablePrefix);
        if (envSettings.imperativeLogLevel.value != null && envSettings.imperativeLogLevel.value.trim().length > 0) {
            if (logger_1.Logger.isValidLevel(envSettings.imperativeLogLevel.value.trim())) {
                // set the imperative log level based on the user's environmental variable, if any
                loggingConfig.log4jsConfig.categories[logger_1.Logger.DEFAULT_IMPERATIVE_NAME].level = envSettings.imperativeLogLevel.value;
                this.log.info("Set imperative log level to %s from environmental variable setting '%s'", envSettings.imperativeLogLevel.value, envSettings.imperativeLogLevel.key);
            }
            else {
                message = "Imperative log level '" + envSettings.imperativeLogLevel.value +
                    "' from environmental variable setting '" + envSettings.imperativeLogLevel.key + "' is not recognised.  " +
                    "Logger level is set to '" + logger_1.LoggerConfigBuilder.DEFAULT_LOG_LEVEL + "'.  " +
                    "Valid levels are " + logger_1.Logger.DEFAULT_VALID_LOG_LEVELS.toString();
                new console_1.Console().warn(message);
                this.log.warn(message);
            }
        }
        else {
            this.log.warn("Environmental setting for imperative log level ('%s') was blank.", envSettings.imperativeLogLevel.key);
        }
        if (envSettings.appLogLevel.value != null && envSettings.appLogLevel.value.trim().length > 0) {
            if (logger_1.Logger.isValidLevel(envSettings.appLogLevel.value.trim())) {
                // set the app log level based on the user's environmental variable, if any
                loggingConfig.log4jsConfig.categories[logger_1.Logger.DEFAULT_APP_NAME].level = envSettings.appLogLevel.value;
                this.log.info("Set app log level to %s from environmental variable setting '%s'", envSettings.appLogLevel.value, envSettings.appLogLevel.key);
            }
            else {
                message = "Application log level '" + envSettings.appLogLevel.value +
                    "' from environmental variable setting '" + envSettings.appLogLevel.key + "' is not recognised.  " +
                    "Logger level is set to '" + logger_1.LoggerConfigBuilder.DEFAULT_LOG_LEVEL + "'.  " +
                    "Valid levels are " + logger_1.Logger.DEFAULT_VALID_LOG_LEVELS.toString();
                new console_1.Console().warn(message);
                this.log.warn(message);
            }
        }
        else {
            this.log.warn("Environmental setting for app log level ('%s') was blank.", envSettings.appLogLevel.key);
        }
        /**
         * Setup log4js
         */
        logger_1.Logger.initLogger(loggingConfig);
    }
    /**
     * Initialize the profiles directory with types and meta files. This can be called every startup of the CLI
     * without issue, but if the meta files or configuration changes, we'll have to re-initialize.
     * TODO: Determine the re-initialize strategy.
     * @private
     * @static
     * @param {IImperativeConfig} config - The configuration document passed to init.
     * @memberof Imperative
     */
    static initProfiles(config) {
        if (!util_1.isNullOrUndefined(config.profiles) && config.profiles.length > 0) {
            cmd_1.CliProfileManager.initialize({
                configuration: config.profiles,
                profileRootDirectory: profiles_1.ProfileUtils.constructProfilesRootDirectory(utilities_1.ImperativeConfig.instance.cliHome),
                reinitialize: false
            });
        }
    }
    /**
     * Define to yargs for main CLI and plugins
     *
     * @param {ICommandDefinition} preparedHostCliCmdTree - The Root of the imperative host CLI
     *        which has already prepared by ImperativeConfig.getPreparedCmdTree.
     */
    static defineCommands(preparedHostCliCmdTree) {
        const commandResponseParms = {
            primaryTextColor: utilities_1.ImperativeConfig.instance.loadedConfig.primaryTextColor,
            progressBarSpinner: utilities_1.ImperativeConfig.instance.loadedConfig.progressBarSpinner
        };
        // do not retrieve command line if invoked from test as argv is undefined
        if (this.yargs.argv !== undefined) {
            // retrieve the arguments to re-build the command entered
            const argV = this.yargs.argv;
            let commandText = "";
            let i;
            // retrieve the groups, command and positional arguments
            for (i = 0; i < argV._.length; i++) {
                commandText = commandText + argV._[i] + " ";
            }
            // retrieve the options and arguments specified
            for (const key in argV) {
                if (argV.hasOwnProperty(key) && (key !== "_" && key !== "$0")) {
                    commandText = commandText + "--" + key + " " + argV[key] + " ";
                }
            }
            this.mCommandLine = commandText.trim();
        }
        else {
            this.mCommandLine = "";
        }
        // Configure Yargs to meet the CLI's needs
        new cmd_1.YargsConfigurer(preparedHostCliCmdTree, Imperative.yargs, commandResponseParms, new ImperativeProfileManagerFactory_1.ImperativeProfileManagerFactory(this.api), this.mHelpGeneratorFactory, utilities_1.ImperativeConfig.instance.loadedConfig.experimentalCommandDescription, Imperative.rootCommandName, Imperative.commandLine, Imperative.envVariablePrefix, EnvironmentalVariableSettings_1.EnvironmentalVariableSettings.read(this.envVariablePrefix).promptPhrase.value ||
            constants_1.Constants.DEFAULT_PROMPT_PHRASE // allow environmental variable to override the default prompt phrase
        ).configure();
        // Define the commands to yargs
        cmd_1.CommandYargs.defineOptionsToYargs(Imperative.yargs, preparedHostCliCmdTree.options);
        const definer = new cmd_1.YargsDefiner(Imperative.yargs, utilities_1.ImperativeConfig.instance.loadedConfig.primaryTextColor, Imperative.rootCommandName, Imperative.commandLine, Imperative.envVariablePrefix, new ImperativeProfileManagerFactory_1.ImperativeProfileManagerFactory(this.api), this.mHelpGeneratorFactory, utilities_1.ImperativeConfig.instance.loadedConfig.experimentalCommandDescription, EnvironmentalVariableSettings_1.EnvironmentalVariableSettings.read(this.envVariablePrefix).promptPhrase.value ||
            constants_1.Constants.DEFAULT_PROMPT_PHRASE // allow environmental variable to override the default prompt phrase
        );
        for (const child of preparedHostCliCmdTree.children) {
            definer.define(child, (args, response) => {
                if (response.success) {
                    if (response.exitCode == null) {
                        response.exitCode = 0;
                    }
                }
                else {
                    if (response.exitCode == null) {
                        response.exitCode = constants_1.Constants.ERROR_EXIT_CODE;
                    }
                }
                process.exitCode = response.exitCode;
            }, commandResponseParms);
        }
        Imperative.mFullCommandTree = preparedHostCliCmdTree;
        cmd_1.WebHelpManager.instance.fullCommandTree = Imperative.mFullCommandTree;
    }
    /**
     * Construct the API object for return to caller of init()
     * @return {ImperativeApi}: The API object
     */
    static constructApiObject() {
        const apiParms = {
            imperativeLogger: this.constructImperativeLoggerApi(),
            appLogger: this.constructAppLoggerApi()
        };
        let api = new ImperativeApi_1.ImperativeApi(apiParms, utilities_1.ImperativeConfig.instance.loadedConfig, utilities_1.ImperativeConfig.instance.cliHome);
        /**
         * Add dynamic API methods to API object
         */
        api = this.constructDynamicLoggersApi(api);
        return api;
    }
    /**
     * Build the Logger API object for the app using the framework
     * @return {Logger}: returns the app Logger API object
     */
    static constructAppLoggerApi() {
        return logger_1.Logger.getAppLogger();
    }
    /**
     * Build the imperative API object for the app using the framework
     * @return {Logger}: returns the imperative Logger API object
     */
    static constructImperativeLoggerApi() {
        return logger_1.Logger.getImperativeLogger();
    }
    /**
     * Build the default console API object for the framework
     * @return {Logger}: returns the default console Logger API object
     */
    static constructConsoleApi() {
        if (util_1.isNullOrUndefined(Imperative.mConsoleLog)) {
            Imperative.mConsoleLog = logger_1.Logger.getConsoleLogger();
            return Imperative.mConsoleLog;
        }
        else {
            return Imperative.mConsoleLog;
        }
    }
    static constructDynamicLoggersApi(api) {
        const loadedConfig = utilities_1.ImperativeConfig.instance.loadedConfig;
        if (loadedConfig.logging.additionalLogging != null &&
            loadedConfig.logging.additionalLogging.length > 0) {
            for (const logConfig of loadedConfig.logging.additionalLogging) {
                api.addAdditionalLogger(logConfig.apiName, logger_1.Logger.getLoggerCategory(logConfig.apiName));
            }
        }
        return api;
    }
    /**
     * Get imperative's host CLI command tree with all module globs resolved.
     *
     * @return {ICommandDefinition} The resolved command tree
     */
    static getResolvedCmdTree(config) {
        return DefinitionTreeResolver_1.DefinitionTreeResolver.resolve(config.rootCommandDescription || "", config.productDisplayName, path_1.dirname(utilities_1.ImperativeConfig.instance.callerLocation), this.log, config.definitions, config.commandModuleGlobs);
    }
    /**
     * Get imperative's host CLI command tree after final preparation.
     *
     * @param resolvedCmdTree - The imperative command tree
     *        returned by Imperative.getResolvedCmdTree()
     */
    static getPreparedCmdTree(resolvedCmdTree) {
        let preparedCmdTree = this.addAutoGeneratedCommands(resolvedCmdTree);
        preparedCmdTree = cmd_1.CommandPreparer.prepare(preparedCmdTree);
        return preparedCmdTree;
    }
    /**
     * Append any auto generated commands to the root command document depending on configuration.
     * @param {ICommandDefinition} rootCommand - the root command as built so far
     * @returns {ICommandDefinition} - the root command with any auto generated commands appended
     */
    static addAutoGeneratedCommands(rootCommand) {
        const loadedConfig = utilities_1.ImperativeConfig.instance.loadedConfig;
        if ((loadedConfig.autoGenerateProfileCommands == null || loadedConfig.autoGenerateProfileCommands) &&
            loadedConfig.profiles != null &&
            loadedConfig.profiles.length > 0) {
            rootCommand.children.push(CompleteProfilesGroupBuilder_1.CompleteProfilesGroupBuilder.getProfileGroup(loadedConfig.profiles, this.log));
        }
        return rootCommand;
    }
}
Imperative.DEFAULT_DEBUG_FILE = path_1.join(process.cwd(), "imperative_debug.log");
Imperative.yargs = require("yargs");
exports.Imperative = Imperative;
//# sourceMappingURL=Imperative.js.map