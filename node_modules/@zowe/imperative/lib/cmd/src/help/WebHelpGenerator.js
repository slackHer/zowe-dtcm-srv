"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const DefaultHelpGenerator_1 = require("./DefaultHelpGenerator");
const error_1 = require("../../../error");
const logger_1 = require("../../../logger");
const marked = require("marked");
class WebHelpGenerator {
    constructor(fullCommandTree, config, webHelpDir) {
        this.sanitizeHomeDir = false;
        this.mFullCommandTree = fullCommandTree;
        this.mConfig = config;
        this.mDocsDir = path.join(webHelpDir, "docs");
        this.treeNodes = [];
        this.aliasList = {};
    }
    buildHelp(cmdResponse) {
        // Log using buffer to prevent trailing newline from getting added
        // This allows printing dot characters on the same line to show progress
        cmdResponse.console.log(Buffer.from("Generating web help"));
        // Create web-help folder
        // After upgrading to Node v10, this step should no longer be necessary
        // if the option recursive=True is used when the docs dir is created
        // below
        const webHelpDir = path.join(this.mDocsDir, "..");
        if (!fs.existsSync(webHelpDir)) {
            fs.mkdirSync(webHelpDir);
        }
        // Create web-help/docs folder
        if (fs.existsSync(this.mDocsDir)) {
            fs.removeSync(path.join(this.mDocsDir, "*"));
        }
        else {
            fs.mkdirSync(this.mDocsDir);
        }
        // Copy files from dist folder to .zowe home dir
        const distDir = this.webHelpDistDir;
        const dirsToCopy = [distDir, path.join(distDir, "css"), path.join(distDir, "js")];
        dirsToCopy.forEach((dir) => {
            const destDir = path.join(webHelpDir, path.relative(distDir, dir));
            if (!fs.existsSync(destDir)) {
                fs.mkdirSync(destDir);
            }
            fs.readdirSync(dir)
                .filter((pathname) => fs.statSync(path.join(dir, pathname)).isFile())
                .forEach((filename) => fs.copySync(path.join(dir, filename), path.join(destDir, filename)));
        });
        // Copy header image if it exists
        if (this.mConfig.loadedConfig.webHelpLogoImgPath) {
            fs.copySync(this.mConfig.loadedConfig.webHelpLogoImgPath, path.join(webHelpDir, "header-image.png"));
        }
        // Replace main.css with custom CSS file if it exists
        if (this.mConfig.loadedConfig.webHelpCustomCssPath) {
            fs.copySync(this.mConfig.loadedConfig.webHelpCustomCssPath, path.join(webHelpDir, "css/main.css"));
        }
        // Sort all items in the command tree and remove duplicates
        const uniqueDefinitions = this.mFullCommandTree;
        uniqueDefinitions.children = uniqueDefinitions.children
            .sort((a, b) => a.name.localeCompare(b.name))
            .filter((a, pos, self) => self.findIndex((b) => a.name === b.name) === pos);
        // Generate HTML help file for the root CLI command
        const rootCommandName = this.mConfig.rootCommandName;
        const rootHelpHtmlPath = path.join(this.mDocsDir, `${rootCommandName}.html`);
        this.treeNodes.push({ id: `${rootCommandName}.html`, text: rootCommandName });
        let rootHelpContent = this.genDocsHeader(rootCommandName);
        rootHelpContent += `<h2><a href="${rootCommandName}.html">${rootCommandName}</a></h2>\n`;
        rootHelpContent += marked(this.mConfig.loadedConfig.rootCommandDescription) + "\n";
        const helpGen = new DefaultHelpGenerator_1.DefaultHelpGenerator({ produceMarkdown: true, rootCommandName }, { commandDefinition: uniqueDefinitions, fullCommandTree: uniqueDefinitions });
        rootHelpContent += marked(`<h4>Groups</h4>\n` + this.buildChildrenSummaryTables(helpGen, rootCommandName));
        rootHelpContent += this.genDocsFooter();
        fs.writeFileSync(rootHelpHtmlPath, rootHelpContent);
        cmdResponse.console.log(Buffer.from("."));
        // Generate HTML help files for every CLI command
        uniqueDefinitions.children.forEach((def) => {
            cmdResponse.console.log(Buffer.from("."));
            this.genCommandHelpPage(def, def.name, this.mDocsDir, this.treeNodes[0]);
        });
        this.writeTreeData();
        cmdResponse.console.log("done!");
    }
    get webHelpDistDir() {
        const runtimeDistDir = path.join(path.dirname(process.mainModule.filename), "..", "node_modules", "@zowe", "imperative", "web-help", "dist");
        let distDir = runtimeDistDir;
        if (!fs.existsSync(runtimeDistDir)) {
            const impLogger = logger_1.Logger.getImperativeLogger();
            impLogger.error("webHelpDistDir: The web-help runtime distribution directory does not exist:\n    " +
                runtimeDistDir + "\n    " +
                "To work in a development environment, we will also try a source directory.");
            /* During development we do not have a runtime distribution path,
             * so fallback to a source directory path.
             */
            distDir = path.join(__dirname, "../../../..", "web-help", "dist");
            if (!fs.existsSync(distDir)) {
                impLogger.error("webHelpDistDir: The web-help source distribution directory does not exist:\n    " +
                    distDir);
                /* The dev directory was just an in-house fallback.
                 * If neither exist, just report the runtime directory to our user.
                 */
                throw new error_1.ImperativeError({
                    msg: `The web-help distribution directory does not exist:\n    "${runtimeDistDir}"`
                });
            }
        }
        return distDir;
    }
    genDocsHeader(title) {
        return `<!DOCTYPE html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>${title}</title>
<link rel="stylesheet" href="../css/bundle-docs.css">
<link rel="stylesheet" href="../css/docs.css">
<article class="markdown-body">
`;
    }
    genDocsFooter() {
        return `</article>
<script src="../js/bundle-docs.js"></script>
<script src="../js/docs.js"></script>
`;
    }
    /**
     * Builds breadcrumb of HTML links to show command ancestry
     * @param {string} rootCommandName
     * @param {string} fullCommandName
     * @returns {string}
     */
    genBreadcrumb(rootCommandName, fullCommandName) {
        const crumbs = [];
        let hrefPrefix = "";
        [rootCommandName, ...fullCommandName.split("_")].forEach((linkText) => {
            crumbs.push(`<a href="${hrefPrefix}${linkText}.html">${linkText}</a>`);
            hrefPrefix += `${linkText}_`;
        });
        return crumbs.join(" â†’ ");
    }
    /**
     * Builds list of groups/commands with HTML links added
     * @param {DefaultHelpGenerator} helpGen
     * @param {string} fullCommandName
     * @returns {string}
     */
    buildChildrenSummaryTables(helpGen, fullCommandName) {
        const hrefPrefix = fullCommandName + "_";
        return helpGen.buildChildrenSummaryTables().split(/\r?\n/g)
            .slice(1) // Delete header line
            .map((line) => {
            // Wrap group/command names inside links
            const match = line.match(/^\s*([a-z0-9-]+(?:\s\|\s[a-z0-9-]+)*)\s+[A-Z]/);
            if (match) {
                const href = `${hrefPrefix}${match[1].split(" ")[0]}.html`;
                return `\n* <a href="${href}">${match[1]}</a> -` + line.slice(match[0].length - 2);
            }
            return " " + line.trim();
        }).join("");
    }
    /**
     * Generates HTML help page for Imperative command
     * @param {ICommandDefinition} definition
     * @param {string} fullCommandName
     * @param {string} docsDir
     * @param {ITreeNode} parentNode
     */
    genCommandHelpPage(definition, fullCommandName, docsDir, parentNode) {
        const rootCommandName = this.treeNodes[0].text;
        const helpGen = new DefaultHelpGenerator_1.DefaultHelpGenerator({ produceMarkdown: true, rootCommandName }, { commandDefinition: definition, fullCommandTree: this.mFullCommandTree });
        let markdownContent = helpGen.buildHelp() + "\n";
        markdownContent = markdownContent.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (definition.type === "group") {
            // this is disabled for the CLIReadme.md but we want to show children here
            // so we'll call the help generator's children summary function even though
            // it's usually skipped when producing markdown
            markdownContent += `<h4>Commands</h4>\n` + this.buildChildrenSummaryTables(helpGen, rootCommandName + "_" + fullCommandName);
        }
        let htmlContent = this.genDocsHeader(fullCommandName.replace(/_/g, " "));
        htmlContent += `<h2>` + this.genBreadcrumb(rootCommandName, fullCommandName) + `</h2>\n`;
        htmlContent += marked(markdownContent) + this.genDocsFooter();
        // Remove backslash escapes from URLs
        htmlContent = htmlContent.replace(/(%5C(?=.+?>.+?<\/a>)|\\(?=\..+?<\/a>))/g, "");
        // Add Copy buttons after command line examples
        htmlContent = htmlContent.replace(/<code>\$\s*(.*?)<\/code>/g, "<code>$1</code> <button class=\"btn-copy\" data-balloon-pos=\"right\" data-clipboard-text=\"$1\">Copy</button>");
        // Sanitize references to user's home directory
        if (this.sanitizeHomeDir) {
            const homeDir = path.dirname(this.mConfig.loadedConfig.defaultHome);
            htmlContent = htmlContent.replace(new RegExp(homeDir.replace(/[\\/]/g, "."), "g"), homeDir.slice(0, homeDir.lastIndexOf(path.sep) + 1) + "&lt;user&gt;");
        }
        const helpHtmlFile = `${rootCommandName}_${fullCommandName.trim()}.html`;
        const helpHtmlPath = path.join(docsDir, helpHtmlFile);
        fs.writeFileSync(helpHtmlPath, htmlContent);
        // Add command node and list of aliases to tree data
        const childNode = {
            id: helpHtmlFile,
            text: [definition.name, ...definition.aliases].join(" | ")
        };
        parentNode.children = [...(parentNode.children || []), childNode];
        definition.aliases.forEach((alias) => {
            if (alias !== definition.name) {
                if (this.aliasList[alias] === undefined) {
                    this.aliasList[alias] = [definition.name];
                }
                else if (this.aliasList[alias].indexOf(definition.name) === -1) {
                    this.aliasList[alias].push(definition.name);
                }
            }
        });
        // Recursively generate HTML help pages if this group/command has children
        if (definition.children) {
            definition.children.forEach((child) => {
                this.genCommandHelpPage(child, `${fullCommandName}_${child.name}`, docsDir, childNode);
            });
        }
    }
    writeTreeData() {
        const treeDataPath = path.join(this.mDocsDir, "..", "tree-data.js");
        fs.writeFileSync(treeDataPath, "/* This file is automatically generated, do not edit manually! */\n" +
            `const headerStr = "${this.mConfig.loadedConfig.productDisplayName}";\n` +
            `const footerStr = "${this.mConfig.callerPackageJson.name} ${this.mConfig.callerPackageJson.version}";\n` +
            "const treeNodes = " + JSON.stringify(this.treeNodes, null, 2) + ";\n" +
            "const aliasList = " + JSON.stringify(this.aliasList, null, 2) + ";\n" +
            "const cmdToLoad = null;");
    }
}
exports.WebHelpGenerator = WebHelpGenerator;
//# sourceMappingURL=WebHelpGenerator.js.map