"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../../../logger");
const CommandProcessor_1 = require("../CommandProcessor");
const constants_1 = require("../../../constants");
const CommandResponse_1 = require("../response/CommandResponse");
const WebHelpManager_1 = require("../help/WebHelpManager");
/**
 * Abstract Yargs Bright Command - Contains base methods for defining commands and groups
 */
class AbstractCommandYargs {
    /**
     * Construct the yargs command instance for imperative. Provides the ability to define Imperative commands to Yargs.
     * @param {IYargsParms} yargsParms - Parameter object contains parms for Imperative/Yargs and command response objects
     */
    constructor(yargsParms) {
        this.yargsParms = yargsParms;
        this.log = logger_1.Logger.getImperativeLogger();
        this.mYargsInstance = yargsParms.yargsInstance;
        this.mDefinition = yargsParms.commandDefinition;
        this.mParent = yargsParms.yargsParent;
        this.mCommandResponseParms = yargsParms.commandResponseParms;
        this.mProfileManagerFactory = yargsParms.profileManagerFactory;
        this.mHelpGeneratorFactory = yargsParms.helpGeneratorFactory;
        this.mRootCommandName = yargsParms.rootCommandName;
        this.mCommandLine = yargsParms.commandLine;
        this.mEnvVariablePrefix = yargsParms.envVariablePrefix;
        this.mPromptPhrase = yargsParms.promptPhrase;
    }
    /**
     * Accessor for the root command name for the CLI
     * @readonly
     * @protected
     * @type {string}
     * @memberof AbstractCommandYargs
     */
    get rootCommandName() {
        return this.mRootCommandName;
    }
    /**
     * Accessor for the command line
     * @readonly
     * @type {string}
     * @memberof AbstractCommandYargs
     */
    get commandLine() {
        return this.mCommandLine;
    }
    /**
     * Accessor for the Environmental variable prefix
     * @readonly
     * @protected
     * @type {string}
     * @memberof AbstractCommandYargs
     */
    get envVariablePrefix() {
        return this.mEnvVariablePrefix;
    }
    get promptPhrase() {
        return this.mPromptPhrase;
    }
    /**
     * Accessor for the command response parms (for subclasses)
     * @return {ICommandResponseParms} - Command response object
     */
    get responseParms() {
        return this.mCommandResponseParms;
    }
    /**
     * Accessor for the help generator factory.
     * @readonly
     * @protected
     * @type {HelpGeneratorFactory}
     * @memberof AbstractCommandYargs
     */
    get helpGeneratorFactory() {
        return this.mHelpGeneratorFactory;
    }
    /**
     * Accessor for the profile manager factory
     * @readonly
     * @type {IProfileManagerFactory<any>}
     * @memberof AbstractCommandYargs
     */
    get profileManagerFactory() {
        return this.mProfileManagerFactory;
    }
    /**
     * Returns a copy of the definition.
     * @return {ICommandDefinition}: A copy of the definition.
     */
    get definition() {
        return JSON.parse(JSON.stringify(this.mDefinition));
    }
    /**
     * Returns the Yargs instance.
     * @return {yargs.Argv}: The Yargs instance.
     */
    get yargs() {
        return this.mYargsInstance;
    }
    /**
     * Get the array of parents.
     * @return {GroupCommandYargs[]}: The array of parents.
     */
    get parents() {
        let parents = [];
        if (this.mParent) {
            parents = parents.concat(this.mParent.parents);
            parents.push(this.mParent);
        }
        return parents;
    }
    /**
     * Construct the Bright command definition "tree" - the full definition document including all parents.
     * @return {ICommandDefinition}: The command definition "tree".
     */
    constructDefinitionTree() {
        const parents = this.parents;
        return (parents[0]) ? JSON.parse(JSON.stringify(parents[0].definition)) : {};
    }
    /**
     * Build The Bright Yargs response for the callback. Includes the Bright command response and status info.
     * @param {boolean} successful: True if the command succeeded
     * @param {string} responseMessage: Response message for display purposes.
     * @param {ImperativeYargsCommandAction} action
     * @param {ICommandResponse[]} responses
     * @return {IYargsResponse}
     */
    getBrightYargsResponse(successful, responseMessage, action, responses) {
        let exitCode;
        if (responses != null && responses.length > 0) {
            for (const response of responses) {
                // use the maximum exit code from all command responses
                if (exitCode == null || (response.exitCode != null && response.exitCode > exitCode)) {
                    exitCode = response.exitCode;
                }
            }
        }
        return {
            success: successful,
            message: responseMessage,
            exitCode,
            actionPerformed: action,
            commandResponses: responses || []
        };
    }
    /**
     * Execute the help Command for the definition.
     * @param {YargsCommandCompleted} commandExecuted: The callback when help is complete.
     * @param {Arguments} args: The arguments passed by the user - used for -y.
     */
    executeHelp(args, commandExecuted) {
        /**
         * Allocate the command processor and command response object to execute the help. The command response
         * object is recreated/changed based on the currently specified CLI options
         */
        const newHelpGenerator = this.helpGeneratorFactory.getHelpGenerator({
            commandDefinition: this.definition,
            fullCommandTree: this.constructDefinitionTree(),
            experimentalCommandsDescription: this.yargsParms.experimentalCommandDescription
        });
        let invoked = false;
        let response;
        try {
            response = new CommandProcessor_1.CommandProcessor({
                definition: this.definition,
                fullDefinition: this.constructDefinitionTree(),
                helpGenerator: newHelpGenerator,
                profileManagerFactory: this.profileManagerFactory,
                rootCommandName: this.rootCommandName,
                commandLine: this.commandLine,
                envVariablePrefix: this.envVariablePrefix,
                promptPhrase: this.promptPhrase
            }).help(new CommandResponse_1.CommandResponse({
                silent: false,
                responseFormat: (args[constants_1.Constants.JSON_OPTION] || false) ? "json" : "default",
            }));
        }
        catch (helpErr) {
            const errorResponse = this.getBrightYargsResponse(false, `The help for ${this.definition.name} was invoked and failed.`, "help invoked");
            errorResponse.causeErrors = helpErr;
            invoked = true;
            commandExecuted(args, errorResponse);
        }
        if (!invoked) {
            commandExecuted(args, this.getBrightYargsResponse(true, `The help for ${this.definition.name} was invoked.`, "help invoked", [response]));
        }
    }
    executeWebHelp() {
        let fullCommandName = this.rootCommandName;
        for (const parent of this.parents) {
            fullCommandName += "_" + parent.definition.name;
        }
        WebHelpManager_1.WebHelpManager.instance.openHelp(fullCommandName + "_" + this.definition.name, new CommandResponse_1.CommandResponse({ silent: false }));
    }
}
/**
 * TODO: REMOVE THIS, workaround for yargs.fail() problem
 * @type {boolean}
 */
AbstractCommandYargs.STOP_YARGS = false;
exports.AbstractCommandYargs = AbstractCommandYargs;
//# sourceMappingURL=AbstractCommandYargs.js.map