"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const logger_1 = require("../../../logger");
const constants_1 = require("../../../constants");
const AbstractCommandYargs_1 = require("./AbstractCommandYargs");
const CommandProcessor_1 = require("../CommandProcessor");
const CommandUtils_1 = require("../utils/CommandUtils");
const CliUtils_1 = require("../../../utilities/src/CliUtils");
/**
 * Before invoking commands, this class configures some settings and callbacks in Yargs,
 * including what happens on syntax failures.
 */
class YargsConfigurer {
    constructor(rootCommand, yargs, commandRespParms, profileManagerFactory, helpGeneratorFactory, experimentalCommandDescription, rootCommandName, commandLine, envVariablePrefix, promptPhrase) {
        this.rootCommand = rootCommand;
        this.yargs = yargs;
        this.commandRespParms = commandRespParms;
        this.profileManagerFactory = profileManagerFactory;
        this.helpGeneratorFactory = helpGeneratorFactory;
        this.experimentalCommandDescription = experimentalCommandDescription;
        this.rootCommandName = rootCommandName;
        this.commandLine = commandLine;
        this.envVariablePrefix = envVariablePrefix;
        this.promptPhrase = promptPhrase;
    }
    configure() {
        /**
         * Add the command definitions to yargs
         */
        const jsonResponseFormat = (process.argv.indexOf(CliUtils_1.CliUtils.getDashFormOfOption(constants_1.Constants.JSON_OPTION)) >= 0 ||
            process.argv.indexOf(CliUtils_1.CliUtils.getDashFormOfOption(constants_1.Constants.JSON_OPTION_ALIAS)) >= 0);
        const logger = logger_1.Logger.getImperativeLogger();
        const jsonArg = {};
        if (jsonResponseFormat) {
            const jsonOptionName = constants_1.Constants.JSON_OPTION;
            jsonArg[jsonOptionName] = true;
        }
        const preferredTerminalWidth = 100;
        const failedCommandHandler = __dirname + "/../handlers/FailedCommandHandler";
        const failedCommandDefinition = {
            name: this.rootCommandName + " " + this.commandLine,
            handler: failedCommandHandler,
            type: "command",
            description: "The command you tried to invoke failed"
        };
        this.yargs.showHelpOnFail(false);
        // finally, catch any undefined commands
        this.yargs.command("*", "Unknown group", (argv) => {
            return argv; // no builder
        }, (argv) => {
            const attemptedCommand = argv._.join(" ");
            if (attemptedCommand.trim().length === 0) {
                if (argv.V) {
                    argv.version = true;
                }
                const isJson = argv[constants_1.Constants.JSON_OPTION] || argv[constants_1.Constants.JSON_OPTION_ALIAS];
                // Allocate a help generator from the factory
                const rootHelpGenerator = this.helpGeneratorFactory.getHelpGenerator({
                    commandDefinition: this.rootCommand,
                    fullCommandTree: this.rootCommand,
                    experimentalCommandsDescription: this.experimentalCommandDescription
                });
                new CommandProcessor_1.CommandProcessor({
                    definition: this.rootCommand, fullDefinition: this.rootCommand,
                    helpGenerator: rootHelpGenerator,
                    profileManagerFactory: this.profileManagerFactory,
                    rootCommandName: this.rootCommandName,
                    commandLine: this.commandLine,
                    envVariablePrefix: this.envVariablePrefix,
                    promptPhrase: this.promptPhrase
                }).invoke({ arguments: argv, silent: false, responseFormat: (jsonResponseFormat) ? "json" : "default" })
                    .then((response) => {
                    logger_1.Logger.getImperativeLogger().debug("Root help complete.");
                })
                    .catch((rejected) => {
                    process.stderr.write("Internal Imperative Error: Root command help error occurred: "
                        + rejected.message + "\n");
                    logger_1.Logger.getImperativeLogger().error(`Root unexpected help error: ${util_1.inspect(rejected)}`);
                });
            }
            else {
                // unknown command, not successful
                process.exitCode = constants_1.Constants.ERROR_EXIT_CODE;
                const lev = require("levenshtein");
                let minimumLevDistance = 999999;
                let closestCommand;
                const commandTree = CommandUtils_1.CommandUtils.flattenCommandTree(this.rootCommand);
                for (const command of commandTree) {
                    if (command.fullName.trim().length === 0) {
                        continue;
                    }
                    const compare = new lev(attemptedCommand, command.fullName);
                    if (compare.distance < minimumLevDistance) {
                        minimumLevDistance = compare.distance;
                        closestCommand = command.fullName;
                    }
                }
                argv.failureMessage = this.buildFailureMessage(closestCommand);
                // Allocate a help generator from the factory
                const rootHelpGenerator = this.helpGeneratorFactory.getHelpGenerator({
                    commandDefinition: failedCommandDefinition,
                    fullCommandTree: failedCommandDefinition,
                    experimentalCommandsDescription: this.experimentalCommandDescription
                });
                // Create the command processor for the fail command
                const failCommand = new CommandProcessor_1.CommandProcessor({
                    definition: failedCommandDefinition,
                    fullDefinition: failedCommandDefinition,
                    helpGenerator: rootHelpGenerator,
                    profileManagerFactory: this.profileManagerFactory,
                    rootCommandName: this.rootCommandName,
                    commandLine: this.commandLine,
                    envVariablePrefix: this.envVariablePrefix,
                    promptPhrase: this.promptPhrase
                });
                // Invoke the fail command
                failCommand.invoke({ arguments: argv, silent: false, responseFormat: (jsonResponseFormat) ? "json" : "default" })
                    .then((failedCommandResponse) => {
                    logger.debug("Finished invoking the 'FailedCommand' handler");
                }).catch((err) => {
                    logger.error("%s", err.msg);
                });
            }
        });
        this.yargs.fail((msg, error, failedYargs) => {
            process.exitCode = constants_1.Constants.ERROR_EXIT_CODE;
            AbstractCommandYargs_1.AbstractCommandYargs.STOP_YARGS = true; // todo: figure out a better way
            error = error || new Error(msg);
            // Allocate a help generator from the factory
            const failHelpGenerator = this.helpGeneratorFactory.getHelpGenerator({
                commandDefinition: failedCommandDefinition,
                fullCommandTree: failedCommandDefinition,
                experimentalCommandsDescription: this.experimentalCommandDescription
            });
            // Create the command processor for the fail command
            const failCommand = new CommandProcessor_1.CommandProcessor({
                definition: failedCommandDefinition,
                fullDefinition: failedCommandDefinition,
                helpGenerator: failHelpGenerator,
                profileManagerFactory: this.profileManagerFactory,
                rootCommandName: this.rootCommandName,
                commandLine: this.commandLine,
                envVariablePrefix: this.envVariablePrefix,
                promptPhrase: this.promptPhrase
            });
            const failureMessage = this.buildFailureMessage();
            // Construct the fail command arguments
            const argv = {
                failureMessage,
                error,
                _: [],
                $0: constants_1.Constants.PRIMARY_COMMAND
            };
            // Invoke the fail command
            failCommand.invoke({ arguments: argv, silent: false, responseFormat: (jsonResponseFormat) ? "json" : "default" })
                .then((failedCommandResponse) => {
                logger.debug("Finished invoking the 'FailedCommand' handler");
            }).catch((err) => {
                logger.error("%s", err.msg);
            });
        });
        process.on("uncaughtException", (error) => {
            process.exitCode = constants_1.Constants.ERROR_EXIT_CODE;
            // Allocate a help generator from the factory
            const failHelpGenerator = this.helpGeneratorFactory.getHelpGenerator({
                commandDefinition: failedCommandDefinition,
                fullCommandTree: failedCommandDefinition,
                experimentalCommandsDescription: this.experimentalCommandDescription
            });
            // Create the command processor for failure
            let failureMessage = "Imperative encountered an unexpected exception";
            const failCommand = new CommandProcessor_1.CommandProcessor({
                definition: failedCommandDefinition,
                fullDefinition: failedCommandDefinition,
                helpGenerator: failHelpGenerator,
                profileManagerFactory: this.profileManagerFactory,
                rootCommandName: this.rootCommandName,
                commandLine: this.commandLine,
                envVariablePrefix: this.envVariablePrefix,
                promptPhrase: this.promptPhrase
            });
            failureMessage += `\nCommand entered: "${this.rootCommandName} ${this.commandLine}"`;
            const groupValues = this.commandLine.split(" ", 2);
            failureMessage += `\nUse "${this.rootCommandName} ${groupValues[0]} ${groupValues[1]} --help" to view groups, commands, and options.`;
            // Construct the arguments
            const argv = {
                failureMessage,
                error,
                _: [],
                $0: constants_1.Constants.PRIMARY_COMMAND
            };
            // Invoke the fail command processor
            failCommand.invoke({ arguments: argv, silent: false, responseFormat: (jsonResponseFormat) ? "json" : "default" })
                .then((failedCommandResponse) => {
                logger.debug("Finished invoking the 'FailedCommand' handler");
            }).catch((err) => {
                logger.error("%s", err.msg);
            });
        });
    }
    /**
     * Builds the failure message that is passed to the failedCommand handler
     * @return {string} - Returns the failure message
     */
    buildFailureMessage(closestCommand) {
        const three = 3;
        let commands = "";
        let groups = " "; // default to " " for proper spacing in message
        let delimiter = ""; // used to delimit between possible 'command' values
        let failureMessage = "Command failed due to improper syntax";
        failureMessage += `\nCommand entered: "${this.rootCommandName} ${this.commandLine}"`;
        // limit to three to include two levels of group and command value, if present
        const groupValues = this.commandLine.split(" ", three);
        // loop through the top level groups
        for (const group of this.rootCommand.children) {
            if ((group.name.trim() === groupValues[0]) || (group.aliases[0] === groupValues[0])) {
                groups += groupValues[0] + " ";
                // found the top level group so loop to see if second level group valid
                for (const group2 of group.children) {
                    if ((group2.name.trim() === groupValues[1]) || (group2.aliases[0] === groupValues[1])) {
                        groups += groupValues[1] + " ";
                        // second level group valid so command provided is invalid, retrieve the valid command(s)
                        for (let i = 0; i < group2.children.length; i++) {
                            if (i > 0) {
                                delimiter = ", ";
                            }
                            commands += delimiter + group2.children[i].name;
                        }
                        break;
                    }
                }
                break;
            }
        }
        if (!util_1.isNullOrUndefined(closestCommand)) {
            failureMessage += util_1.format("\nUnknown group: %s\n", groupValues[0]);
            failureMessage += util_1.format("Did you mean: %s?", closestCommand);
        }
        if (commands.length > 0) {
            failureMessage += `\nAvailable commands are "${commands}".`;
        }
        failureMessage += `\nUse "${this.rootCommandName}${groups}--help" to view groups, commands, and options.`;
        return failureMessage;
    }
}
exports.YargsConfigurer = YargsConfigurer;
//# sourceMappingURL=YargsConfigurer.js.map