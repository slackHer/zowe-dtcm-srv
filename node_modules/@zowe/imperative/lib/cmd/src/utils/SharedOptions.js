"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = require("../../../error");
const constants_1 = require("../../../constants");
const util_1 = require("util");
const logger_1 = require("../../../logger");
/**
 * Options which can be reused between different Brightside commands
 */
class SharedOptions {
    /**
     * Promise based API for reading the standard in if the arguments dictate to do so. The response is placed in the
     * arguments to be passed on the the command handlers.
     * @param {Arguments} args - The yargs style command line arguments supplied by the user
     * @param {CommandResponse} response - The command response object (for messages, etc.)
     * @param {ICommandNodeType} commandType - The type of the command
     * @returns {Promise<boolean>} - The promise to be fulfilled (or rejected with an imperative error) - false if
     *                               stdin was read and false if it wasn't
     * @memberof SharedOptions
     */
    static readStdinIfRequested(args, response, commandType, stream = process.stdin) {
        return new Promise((complete, error) => {
            SharedOptions.readStdin(args, response, commandType, stream, (readErr, attemptedStdinRead) => {
                if (readErr) {
                    error(new error_1.ImperativeError({
                        msg: `An Error occurred reading stdin: ${readErr.msg}`,
                        additionalDetails: readErr.additionalDetails
                    }));
                }
                else {
                    complete(attemptedStdinRead);
                }
            });
        });
    }
    /**
     * Read from standard in until EOF (if the option was specified)
     * @param {Arguments} args - arguments for the command
     * @param {CommandResponse} response - the response object to write to / log to if necessary
     * @param {ICommandNodeType} commandType what type of command might have the --stdin option? If it's not "command"
     *                              this method will return immediately
     * @param {() => void} done - callback for when stdin reading is done. attemptedStdinRead: whether we tried to read standard in
     *                            based on the arguments and command definition
     */
    static readStdin(args, response, commandType, stream = process.stdin, done) {
        /**
         * If this is a module
         */
        if (!args[constants_1.Constants.STDIN_OPTION]) {
            logger_1.Logger.getImperativeLogger().debug("Standard input reading not requested. Skipping stdin read");
            done(undefined, false);
            return;
        }
        /**
         * If --stdin wasn't requested, don't try to read it
         */
        if (commandType !== "command") {
            logger_1.Logger.getImperativeLogger().debug("stdin was requested, but the command definition was not of type 'command'. " +
                "skipping stdin read");
            done(undefined, false);
            return;
        }
        logger_1.Logger.getImperativeLogger().debug("Will attempt to read stdin");
        let stdinContent = Buffer.from([]);
        stream.resume();
        stream.on("data", (chunk) => {
            logger_1.Logger.getImperativeLogger().trace(`Read data from stdin: ${chunk.toString()}`);
            stdinContent = Buffer.concat([stdinContent, chunk]);
        });
        stream.once("end", () => {
            logger_1.Logger.getImperativeLogger().info("Finished reading stdin");
            args[constants_1.Constants.STDIN_CONTENT_KEY] = stdinContent;
            done(undefined, true);
        });
        stream.on("error", (error) => {
            const stdinReadError = {
                msg: "Error encountered while reading from stdin",
                causeErrors: error,
                additionalDetails: (util_1.isNullOrUndefined(error)) ? undefined : error.message
            };
            done(stdinReadError, true);
            // don't call done, we don't want to continue on an error
        });
    }
}
exports.SharedOptions = SharedOptions;
//# sourceMappingURL=SharedOptions.js.map