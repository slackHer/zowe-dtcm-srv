"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const profiles_1 = require("../../../profiles");
const CommandProfiles_1 = require("./CommandProfiles");
const util_1 = require("util");
const logger_1 = require("../../../logger");
const expect_1 = require("../../../expect");
const error_1 = require("../../../error");
/**
 * The command processor profile loader loads all profiles that are required (or optional) given a command
 * definitions requirements. It returns the CommandProfiles object (which contains the map and getters for the
 * command handlers usage).
 * @export
 * @class CommandProfileLoader
 */
class CommandProfileLoader {
    /**
     * Create a new instance of the profile loader
     * @static
     * @param {CommandResponse} response - The command response object, used to formulate messages, logs and errors
     * @param {ICommandDefinition} commandDefinition - The command definition for the command being issued (used to determine
     * what profiles to load for this command)
     * @param {IProfileManagerFactory<ICommandProfileTypeConfiguration>} factory - The profile manager factory (used to
     * obtain instances of profile managers for profiles that are to be loaded)
     * @returns
     * @memberof CommandProfileLoader
     */
    static loader(parms) {
        return new CommandProfileLoader(parms.commandDefinition, parms.profileManagerFactory, parms.logger || logger_1.Logger.getImperativeLogger());
    }
    /**
     * Creates an instance of CommandProfileLoader.
     * @param {ICommandDefinition} commandDefinition - The input command definition for the command being issued.
     * @param {IProfileManagerFactory<ICommandProfileTypeConfiguration>} factory - The profile manager factory
     * @param {any} [logger=Logger.getImperativeLogger()] - A log4js instance
     * @memberof CommandProfileLoader
     */
    constructor(commandDefinition, factory, logger = logger_1.Logger.getImperativeLogger()) {
        const err = "Could not construct the profile loader.";
        expect_1.ImperativeExpect.toNotBeNullOrUndefined(commandDefinition, `${err} No command definition supplied.`);
        expect_1.ImperativeExpect.toNotBeNullOrUndefined(factory, `${err} No profile factory supplied.`);
        this.mCommandDefinition = commandDefinition;
        this.mFactory = factory;
        expect_1.ImperativeExpect.toBeEqual((logger instanceof logger_1.Logger), true, `${err} The "logger" supplied is not of type Logger.`);
        this.mLog = logger;
        this.log.trace(`Profile loader created for command: ${commandDefinition.name}`);
    }
    /**
     * Load the profiles for the command - the command arguments are supplied to grab the profile names from
     * the arguments supplied by the user.
     * @param {Arguments} commandArguments - The command arguments supplied on this command invocation (Yargs style)
     * @returns {Promise<CommandProfiles>} - The promise is fulfilled with the map object OR rejected with an
     * Imperative error
     * @memberof CommandProfileLoader
     */
    loadProfiles(commandArguments) {
        return __awaiter(this, void 0, void 0, function* () {
            // Validate parms
            expect_1.ImperativeExpect.toNotBeNullOrUndefined(commandArguments, `Could not load profiles. No command arguments supplied.`);
            // Log the API call
            this.log.info(`Request to load profiles for command: ${this.definition.name}...`);
            this.log.trace(`Profile load arguments supplied:\n${util_1.inspect(commandArguments, { depth: null })}`);
            // Create the map that eventually will be returned
            const profileMap = new Map();
            // If there are no profile specifications on this command definition document node, then
            // we can immediately exit with an empty map
            if (!util_1.isNullOrUndefined(this.definition.profile)) {
                this.log.trace(`Loading profiles for command: ${this.definition.name}...`);
                const loadList = this.constructLoadList(commandArguments);
                const responses = yield this.loadAll(loadList);
                this.log.debug(`"${responses.length}" profiles loaded.`);
                this.buildCommandMap(responses, profileMap);
                this.log.trace(`All profiles loaded for command: ${this.definition.name}...`);
            }
            // Return the command profiles object for the handler
            return new CommandProfiles_1.CommandProfiles(profileMap);
        });
    }
    /**
     * Builds the command map for input the the command map object for the command handlers
     * @private
     * @param {IProfileLoaded[]} responses - The full list of profiles loaded for this command
     * @param {Map<string, IProfile[]>} map - The map to populate
     * @memberof CommandProfileLoader
     */
    buildCommandMap(responses, map) {
        for (const resp of responses) {
            if (resp.profile) {
                if (util_1.isNullOrUndefined(map.get(resp.type))) {
                    this.log.trace(`Adding first profile "${resp.name}" of type "${resp.type}" to the map.`);
                    map.set(resp.type, [resp.profile]);
                }
                else {
                    this.log.trace(`Adding profile "${resp.name}" of type "${resp.type}" to the map.`);
                    const existing = map.get(resp.type);
                    existing.push(resp.profile);
                }
            }
            else {
                this.log.debug(`Profile load response without a profile: ${resp.message}`);
            }
        }
    }
    /**
     * Builds the list of profiles to load for this command.
     * @private
     * @param {Arguments} commandArguments - The arguments supplied on the command (Yargs Style)
     * @returns {ICommandLoadProfile[]} - The list of profiles to load (and other control information)
     * @memberof CommandProfileLoader
     */
    constructLoadList(commandArguments) {
        let loadProfiles = [];
        this.log.trace(`Building required profiles for the load list...`);
        loadProfiles = this.buildLoad(false, this.definition.profile.required, commandArguments);
        this.log.trace(`Building optional profiles to the load list...`);
        return loadProfiles.concat(this.buildLoad(true, this.definition.profile.optional, commandArguments));
    }
    /**
     * Builds the control parameters for the loading of each profile name/type.
     * @private
     * @param {boolean} optional - If the profile is optional
     * @param {string[]} types - The profile types to load
     * @param {Arguments} commandArguments - The command arguments
     * @returns {ICommandLoadProfile[]} - The list of profiles to load (and control parameters)
     * @memberof CommandProfileLoader
     */
    buildLoad(optional, types, commandArguments) {
        const loadProfiles = [];
        if (!util_1.isNullOrUndefined(types)) {
            // Construct the load control parameters for each required type
            types.forEach((type) => {
                // Assume some defaults
                const load = {
                    name: undefined,
                    type,
                    userSpecified: false,
                    loadDefault: false,
                    optional
                };
                // If the argument is specified, indicate that this is a user specified load and if not
                // assume that the default should be loaded (but still required on the command)
                const [profOpt, profOptAlias] = profiles_1.ProfileUtils.getProfileOptionAndAlias(type);
                if (!util_1.isNullOrUndefined(commandArguments[profOpt])) {
                    load.userSpecified = true;
                    load.name = commandArguments[profOpt];
                }
                else {
                    load.loadDefault = true;
                }
                // Add to the list
                this.log.trace(`Adding load parameters to list: ${util_1.inspect(load, { depth: null })}`);
                loadProfiles.push(load);
            });
        }
        // Return the list
        return loadProfiles;
    }
    /**
     * Invoke the profile managers to load the profiles requested for this command.
     * @private
     * @param {ICommandLoadProfile[]} list - The list of profiles to load and control parameters.
     * @returns {Promise<IProfileLoaded[]>} - The promise to fulfill with the entire load response OR rejected with
     * an Imperative Error.
     * @memberof CommandProfileLoader
     */
    loadAll(list) {
        return __awaiter(this, void 0, void 0, function* () {
            // Attempt to load each profile indicated by the load control parameters
            const loadResponses = [];
            for (const load of list) {
                this.log.debug(`Loading profile "${load.name}" of type "${load.type}".`);
                const response = yield this.factory.getManager(load.type).load({
                    loadDefault: load.loadDefault,
                    name: load.name,
                    failNotFound: !load.optional
                });
                // This is an exceptional case - the manager did not do it's job properly, but we will ensure
                // that if a profile was required (not optional), that it was loaded.
                if (!load.optional && (util_1.isNullOrUndefined(response) || util_1.isNullOrUndefined(response.profile))) {
                    throw new error_1.ImperativeError({
                        msg: `Unexpected internal load error: The profile ` +
                            `"${(load.loadDefault) ? "default requested" : load.name}" was not loaded by the profile manager.`
                    });
                }
                // Push the loaded resposne
                this.log.debug(`Adding dependencies "${response.name}" of type "${response.type}"`);
                loadResponses.push(response);
                // If dependencies have been loaded, we'll flatten the tree and push on the response list.
                if (response.dependenciesLoaded) {
                    this.log.trace(`Dependencies have also been loaded, adding to list...`);
                    const flatten = profiles_1.ProfileUtils.flattenDependencies(response.dependencyLoadResponses);
                    for (const flat of flatten) {
                        this.log.debug(`Adding dependencies "${flat.name}" of type "${flat.type}"`);
                        loadResponses.push(flat);
                    }
                }
            }
            // Return the full list of load responses
            return loadResponses;
        });
    }
    /**
     * Accessor for the profile manager factory
     * @readonly
     * @private
     * @type {IProfileManagerFactory<ICommandProfileTypeConfiguration>}
     * @memberof CommandProfileLoader
     */
    get factory() {
        return this.mFactory;
    }
    /**
     * Accessor for the command definition document
     * @readonly
     * @private
     * @type {ICommandDefinition}
     * @memberof CommandProfileLoader
     */
    get definition() {
        return this.mCommandDefinition;
    }
    /**
     * Accessor for the logging object
     * @readonly
     * @private
     * @type {Logger}
     * @memberof CommandProfileLoader
     */
    get log() {
        return this.mLog;
    }
}
exports.CommandProfileLoader = CommandProfileLoader;
//# sourceMappingURL=CommandProfileLoader.js.map