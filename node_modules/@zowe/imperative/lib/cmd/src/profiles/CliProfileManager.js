"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const profiles_1 = require("../../../profiles");
const util_1 = require("util");
const error_1 = require("../../../error");
const CommandResponse_1 = require("../response/CommandResponse");
const CommandProfiles_1 = require("./CommandProfiles");
const security_1 = require("../../../security");
const CliUtils_1 = require("../../../utilities/src/CliUtils");
/**
 * A profile management API compatible with transforming command line arguments into
 * profiles
 */
class CliProfileManager extends profiles_1.BasicProfileManager {
    /**
     * NOTE: This is just a copy of BasicProfileManager.loadAll
     * REASON: We needed the Abstract profile manager to call the CLI profile manager to handle loading of secure properties
     * Loads all profiles from every type. Profile types are determined by reading all directories within the
     * profile root directory.
     * @returns {Promise<IProfileLoaded[]>} - The list of all profiles for every type
     */
    loadAll(params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.trace(`Loading all profiles for type "${this.profileType}"...`);
            // Load all the other profiles for other types
            const loadAllProfiles = [];
            let loadList = "";
            // Load only the profiles for the type if requested
            if (params != null && params.typeOnly) {
                const names = this.getAllProfileNames();
                for (const name of names) {
                    loadAllProfiles.push(this.load({
                        name,
                        failNotFound: true,
                        loadDependencies: false,
                        noSecure: (params != null) ? params.noSecure : undefined
                    }));
                }
            }
            else {
                // Otherwise, load all profiles of all types
                for (const typeConfig of this.profileTypeConfigurations) {
                    const typeProfileManager = new CliProfileManager({
                        profileRootDirectory: this.profileRootDirectory,
                        typeConfigurations: this.profileTypeConfigurations,
                        type: typeConfig.type,
                        logger: this.log,
                        loadCounter: this.loadCounter
                    });
                    // Get all the profile names for the type and attempt to load every one
                    const names = typeProfileManager.getAllProfileNames();
                    for (const name of names) {
                        this.log.debug(`Loading profile "${name}" of type "${typeConfig.type}".`);
                        loadAllProfiles.push(typeProfileManager.load({
                            name,
                            failNotFound: true,
                            loadDependencies: false,
                            noSecure: (params != null) ? params.noSecure : undefined
                        }));
                        loadList += `\nLoading "${name}" of type "${typeConfig.type}"`;
                    }
                }
            }
            // Construct the full list for return
            let allProfiles = [];
            try {
                this.log.trace(`Awaiting all loads...`);
                const theirProfiles = yield Promise.all(loadAllProfiles);
                for (const theirs of theirProfiles) {
                    allProfiles = allProfiles.concat(theirs);
                }
                this.log.trace(`All loads complete.`);
            }
            catch (e) {
                this.log.error(e.message);
                throw new error_1.ImperativeError({ msg: e.message, additionalDetails: e.additionalDetails, causeErrors: e });
            }
            return allProfiles;
        });
    }
    /**
     * Overridden saveProfile functionality.
     * If CLI args are provided, profile fields are built from the args.
     * Otherwise BaseProfileManager functionality is used.
     * @param {ISaveProfileFromCliArgs} parms - parameters for the save, potentially including CLI args
     * @returns {Promise<IProfileSaved>} - promise which fulfills with the save results
     */
    saveProfile(parms) {
        const _super = Object.create(null, {
            saveProfile: { get: () => super.saveProfile }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // If the arguments are present, build the new profile from the arguments
            // Otherwise, just save the profile passed.
            this.log.trace("Cli save profile entered");
            const validationParms = JSON.parse(JSON.stringify(parms));
            validationParms.readyForValidation = true;
            if (!util_1.isNullOrUndefined(parms.args)) {
                this.log.trace(`Arguments supplied, constructing profile from arguments:\n${util_1.inspect(parms.args, { depth: null })}`);
                parms.profile = yield this.createProfileFromCommandArguments(parms.args, parms.profile);
                validationParms.profile = parms.profile;
                delete parms.args;
                this.log.debug(`Validating profile build (name: ${parms.name}).`);
                yield this.validate(validationParms); // validate now that the profile has been built
            }
            else {
                // profile should already be ready
                this.log.trace("No arguments specified, performing the basic validation (schema, etc.).");
                yield this.validate(validationParms);
            }
            parms.profile = yield this.processSecureProperties(parms.name, parms.profile);
            return _super.saveProfile.call(this, parms);
        });
    }
    /**
     * Overridden updateProfile functionality
     * If CLI args are provided, profile fields are built from the arguments. Otherwise
     * the BaseProfileManager update functionality is used
     *
     * @param {IUpdateProfileFromCliArgs} parms - parameters, potentially including CLI args
     * @returns {Promise<IProfileUpdated>} - promise which contains the updated profile, path, and message
     *                                       when fulfilled
     */
    updateProfile(parms) {
        const _super = Object.create(null, {
            updateProfile: { get: () => super.updateProfile }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // If there are arguments present, then it is assumed that we want to update from the args,
            // otherwise we will invoke the default updateProfile which assumes that the profile update
            // has already been constructed and just needs to be saved.
            // When updating from the args, we do not need to run validation twice when saving the profile
            let updated;
            if (!util_1.isNullOrUndefined(parms.args)) {
                const newManagerParams = JSON.parse(JSON.stringify(this.managerParameters));
                newManagerParams.loadCounter = this.loadCounter;
                newManagerParams.logger = this.log;
                const loadedProfile = yield new CliProfileManager(newManagerParams).loadProfile({ name: parms.name });
                updated = yield this.updateProfileFromCliArgs(parms, loadedProfile.profile, util_1.isNullOrUndefined(parms.profile) ? {} : parms.profile);
                delete parms.args;
                this.log.debug("Profile \"%s\" of type \"%s\" has been updated from CLI arguments. " +
                    "Validating the structure of the profile.", parms.name, this.profileType);
            }
            else {
                updated = yield _super.updateProfile.call(this, parms);
                this.log.debug("No CLI args were provided. Used the BasicProfileManager update API");
                const validationParms = JSON.parse(JSON.stringify(parms));
                validationParms.readyForValidation = true;
                validationParms.profile = updated.profile;
                yield this.validateProfile(validationParms);
                updated.profile = yield this.processSecureProperties(parms.name, updated.profile);
            }
            return updated;
        });
    }
    /**
     * Overridden loadProfile functionality
     * After the BasicProfileManager loads the profile, we process the secured properties for the CLi to use
     *
     * @param {ICliILoadProfile} parms - Load control params - see the interface for full details
     * @returns {Promise<IProfileLoaded>} - Promise that is fulfilled when complete (or rejected with an Imperative Error)
     */
    loadProfile(parms) {
        const _super = Object.create(null, {
            loadProfile: { get: () => super.loadProfile }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const loadedProfile = yield _super.loadProfile.call(this, parms);
            const profile = loadedProfile.profile;
            // If noSecure is specified, skip secure loading
            let securelyLoadValue;
            if (!parms.noSecure && security_1.CredentialManagerFactory.initialized) {
                /**
                 * Securely load a property associated with a given profile
                 * @param {string} propertyNamePath - The path to the property
                 * @return {Promise<string>}
                 */
                securelyLoadValue = (propertyNamePath) => __awaiter(this, void 0, void 0, function* () {
                    let ret;
                    try {
                        this.log.debug(`Loading secured field with key ${propertyNamePath} for profile` +
                            ` ("${parms.name}" of type "${this.profileType}").`);
                        // Use the Credential Manager to store the credentials
                        ret = yield security_1.CredentialManagerFactory.manager.load(profiles_1.ProfileUtils.getProfilePropertyKey(this.profileType, parms.name, propertyNamePath));
                    }
                    catch (err) {
                        this.log.error(`Unable to load secure field "${propertyNamePath}" ` +
                            `associated with profile "${parms.name}" of type "${this.profileType}".`);
                        let additionalDetails = err.message + (err.additionalDetails ? `\n${err.additionalDetails}` : "");
                        additionalDetails = this.addProfileInstruction(additionalDetails);
                        this.log.error(`Error: ${additionalDetails}`);
                        if (err.causeErrors != null) {
                            this.log.error("Cause errors: " + util_1.inspect(err.causeErrors));
                        }
                        throw new error_1.ImperativeError({
                            msg: `Unable to load the secure field "${propertyNamePath}" associated with ` +
                                `the profile "${parms.name}" of type "${this.profileType}".`,
                            additionalDetails,
                            causeErrors: err
                        });
                    }
                    return JSON.parse(ret); // Parse it after loading it. We stringify-ed before saving it
                });
            }
            for (const prop of Object.keys(this.profileTypeConfiguration.schema.properties)) {
                profile[prop] = yield this.findOptions(this.profileTypeConfiguration.schema.properties[prop], prop, profile[prop], securelyLoadValue);
            }
            // Return the loaded profile
            loadedProfile.profile = profile;
            return loadedProfile;
        });
    }
    /**
     * Overridden loadProfile functionality
     * Before the BasicProfileManager deletes the profile, we remove the secure properties associated with the profile
     *
     * @param {IDeleteProfile} parms - Delete control params - see the interface for full details
     * @returns {Promise<IProfileDeleted>} - Promise that is fulfilled when complete (or rejected with an Imperative Error)
     */
    deleteProfile(parms) {
        const _super = Object.create(null, {
            deleteProfile: { get: () => super.deleteProfile }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // If the credential manager is null, we are using plain text
            let deleteSecureProperty;
            if (security_1.CredentialManagerFactory.initialized) {
                /**
                 * Delete a secure property associated with a given profile
                 * @param {string} propertyNamePath - The path to the property
                 * @return {Promise<string>}
                 */
                deleteSecureProperty = (propertyNamePath) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        this.log
                            .debug(`Deleting secured field with key ${propertyNamePath} for profile ("${parms.name}" of type "${this.profileType}").`);
                        // Use the Credential Manager to store the credentials
                        yield security_1.CredentialManagerFactory.manager.delete(profiles_1.ProfileUtils.getProfilePropertyKey(this.profileType, parms.name, propertyNamePath));
                    }
                    catch (err) {
                        this.log.error(`Unable to delete secure field "${propertyNamePath}" ` +
                            `associated with profile "${parms.name}" of type "${this.profileType}".`);
                        let additionalDetails = err.message + (err.additionalDetails ? `\n${err.additionalDetails}` : "");
                        additionalDetails = this.addProfileInstruction(additionalDetails);
                        this.log.error(`Error: ${additionalDetails}`);
                        throw new error_1.ImperativeError({
                            msg: `Unable to delete the secure field "${propertyNamePath}" associated with ` +
                                `the profile "${parms.name}" of type "${this.profileType}".`,
                            additionalDetails,
                            causeErrors: err
                        });
                    }
                });
            }
            for (const prop of Object.keys(this.profileTypeConfiguration.schema.properties)) {
                yield this.findOptions(this.profileTypeConfiguration.schema.properties[prop], prop, null, deleteSecureProperty);
            }
            return _super.deleteProfile.call(this, parms);
        });
    }
    /**
     * Validate a profile's structure, skipping the validation if we haven't built the
     * profile's fields from the CLI arguments yet.
     * @param {IValidateProfileForCLI} parms - validate profile parameters. if these don't
     *                                         have readyForValidation = true, validation is
     *                                         skipped
     * @returns {Promise<IProfileValidated>}
     */
    validateProfile(parms) {
        const _super = Object.create(null, {
            validateProfile: { get: () => super.validateProfile }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (parms.readyForValidation) {
                this.log.debug(`Invoking the basic profile manager validate for profile: "${parms.name}"`);
                return _super.validateProfile.call(this, parms);
            }
            else {
                this.log.trace(`Skipping the validate for profile (as it's being built): "${parms.name}"`);
                return { message: "Skipping validation until profile is built" };
            }
        });
    }
    /**
     * After the DefaultCredentialManager reports an error resolution of recreating
     * a credential, add instruction to recreate the profile.
     *
     * @param {String} errDetails - The additional details of an error thrown
     *      by DefaultCredentialManager.
     *
     * @returns {string} An error details string that contains an instruction to
     *      recreate the profile (when appropriate).
     */
    addProfileInstruction(errDetails) {
        const recreateCredText = "Recreate the credentials in the vault";
        const recreateProfileText = "  To recreate credentials, issue a 'profiles create' sub-command with the --ow flag.\n";
        if (errDetails.includes(recreateCredText)) {
            errDetails += recreateProfileText;
        }
        return errDetails;
    }
    /**
     * Helper routine to find nested properties
     * Inspired by the inner function of insertCliArgumentsIntoProfile
     *
     * @param {ICommandProfileProperty} prop - profile property
     * @param {string} propNamePath - Dot notation path of a property (e.g. my.nested.property)
     * @param {*} propValue - Current value of the property while traversing down the object tree
     * @param {SecureOperationFunction} secureOp - Function to be executed if we are supposed to process secure properties
     * @returns {Promise<any>} Processed version of a property
     */
    findOptions(prop, propNamePath, propValue, secureOp) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!util_1.isNullOrUndefined(prop.optionDefinition)) {
                // once we reach a property with an option definition,
                // we now have the complete path to the property
                // so we will set the value on the property from the profile
                const optionName = prop.optionDefinition.name;
                this.log.debug("Setting profile field %s from command line option %s", propNamePath, optionName);
                if (secureOp && prop.secure) {
                    this.log.debug("Performing secure operation on property %s", propNamePath);
                    return secureOp(propNamePath, propValue);
                }
                return propValue;
            }
            if (!util_1.isNullOrUndefined(prop.properties)) {
                if (secureOp && prop.secure) {
                    if (!propValue || Object.keys(propValue).length === 0) { // prevents from performing operations on empty objects
                        return null;
                    }
                    this.log.debug("Performing secure operation on property %s", propNamePath);
                    return secureOp(propNamePath, propValue);
                }
                const tempProperties = {};
                for (const childPropertyName of Object.keys(prop.properties)) {
                    tempProperties[childPropertyName] =
                        yield this.findOptions(prop.properties[childPropertyName], propNamePath + "." + childPropertyName, (!util_1.isNullOrUndefined(propValue) && !util_1.isNullOrUndefined(propValue[childPropertyName])) ?
                            JSON.parse(JSON.stringify(propValue[childPropertyName])) : null, secureOp);
                }
                return tempProperties;
            }
            return propValue;
        });
    }
    /**
     * Process and store all secure properties and replace them with a constant for display purposes
     * @param name - the name of the profile with which the secure properties are associated
     * @param {IProfile} profile - Profile contents to be processed
     * @return {Promise<IProfile>}
     */
    processSecureProperties(name, profile) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the credential manager is null, skip secure props and the profile will default to plain text
            let securelyStoreValue;
            if (security_1.CredentialManagerFactory.initialized) {
                /**
                 * Securely store a property associated with a given profile
                 * @param {string} propertyNamePath - The path to the property
                 * @param {string} propertyValue - The value associated with the given profile property
                 * @return {Promise<string>}
                 */
                securelyStoreValue = (propertyNamePath, propertyValue) => __awaiter(this, void 0, void 0, function* () {
                    if (util_1.isNullOrUndefined(propertyValue)) { // prevents from storing null values
                        return null;
                    }
                    try {
                        this.log.debug(`Associating secured field with key ${propertyNamePath}` +
                            ` for profile (of type "${this.profileType}").`);
                        // Use the Credential Manager to store the credentials
                        yield security_1.CredentialManagerFactory.manager.save(profiles_1.ProfileUtils.getProfilePropertyKey(this.profileType, name, propertyNamePath), JSON.stringify(propertyValue) // Stringify it before saving it. We will parse after loading it
                        );
                    }
                    catch (err) {
                        this.log.error(`Unable to store secure field "${propertyNamePath}" ` +
                            `associated with profile "${name}" of type "${this.profileType}".`);
                        let additionalDetails = err.message + (err.additionalDetails ? `\n${err.additionalDetails}` : "");
                        additionalDetails = this.addProfileInstruction(additionalDetails);
                        this.log.error(`Error: ${additionalDetails}`);
                        throw new error_1.ImperativeError({
                            msg: `Unable to store the secure field "${propertyNamePath}" associated with ` +
                                `the profile "${name}" of type "${this.profileType}".`,
                            additionalDetails,
                            causeErrors: err
                        });
                    }
                    // The text in the profile will read "managed by <credential manager name>"
                    return `${profiles_1.ProfilesConstants.PROFILES_OPTION_SECURELY_STORED} ${security_1.CredentialManagerFactory.manager.name}`;
                });
            }
            for (const prop of Object.keys(this.profileTypeConfiguration.schema.properties)) {
                profile[prop] = yield this.findOptions(this.profileTypeConfiguration.schema.properties[prop], prop, profile[prop], securelyStoreValue);
            }
            return profile;
        });
    }
    /**
     * Update an existing profile with arguments from the user based on
     * the schema and configuration for this profile type
     * @param {IUpdateProfileFromCliArgs} parms - parameters including args
     * @param {IProfile} oldProfile - the pre-existing profile to update
     * @param {IProfile} newProfile - new profile which will have fields set from CLI args
     * @returns {Promise<IProfileUpdated>}  promise which provides the finished profile on fulfill
     */
    updateProfileFromCliArgs(parms, oldProfile, newProfile) {
        return __awaiter(this, void 0, void 0, function* () {
            // Create the modified profile from the CLI arguments
            const updatedProfile = yield this.updateProfileFieldsFromCommandArguments(oldProfile, newProfile, parms.args, parms.merge);
            // Save the profile (basically just overwrites the old profile)
            let createResponse;
            try {
                this.log.info("Saving updated profile \"%s\" of type \"%s\"", parms.name, this.profileType);
                createResponse = yield this.saveProfile({
                    name: parms.name,
                    type: this.profileType,
                    profile: updatedProfile,
                    updateDefault: false,
                    overwrite: true,
                });
            }
            catch (saveErr) {
                throw new error_1.ImperativeError({
                    msg: `An error occurred while saving the modified profile ` +
                        `("${parms.name}" of type "${this.profileType}"): ${saveErr.message}`
                });
            }
            // Return the success response
            return {
                profile: updatedProfile,
                path: createResponse.path,
                message: `Profile "${parms.name}" of type "${this.profileType}" successfully updated from command line arguments.`
            };
        });
    }
    /**
     *
     * If a custom handler is provided for update, the handler will be loaded and invoked
     * in order to build the finished profile
     * @param {IProfile} oldProfile - the old profile to update
     * @param newProfile - new profile which may have fields populated, which will be updated from the CLI args
     * @param {yargs.Arguments} newArguments - CLi arguments specified by the user
     * @param merge - should the profiles be merged? (will be skipped if there is a custom update profile handler)
     * @returns {Promise<IProfile>} - promise which provides the finished profile on fulfill
     */
    updateProfileFieldsFromCommandArguments(oldProfile, newProfile, newArguments, merge) {
        return __awaiter(this, void 0, void 0, function* () {
            const profileConfig = this.profileTypeConfiguration;
            if (!util_1.isNullOrUndefined(profileConfig.updateProfileFromArgumentsHandler)) {
                // if there is a custom update profile handler, they can call mergeProfile
                // from their handler, so we will not do it for them to avoid issues
                this.log.debug("Loading custom update profile handler: " + profileConfig.updateProfileFromArgumentsHandler);
                const response = new CommandResponse_1.CommandResponse({ silent: true });
                let handler;
                try {
                    const commandHandler = require(profileConfig.updateProfileFromArgumentsHandler);
                    handler = new commandHandler.default();
                }
                catch (e) {
                    const errorMessage = this.log.error(`Error encountered loading custom update profile handler ` +
                        `${profileConfig.updateProfileFromArgumentsHandler}:\n` + +e.message);
                    throw new error_1.ImperativeError({
                        msg: errorMessage,
                        causeErrors: [e],
                        stack: e.stack
                    });
                }
                try {
                    yield handler.process({
                        arguments: CliUtils_1.CliUtils.buildBaseArgs(newArguments),
                        response,
                        fullDefinition: undefined,
                        definition: undefined,
                        profiles: new CommandProfiles_1.CommandProfiles(new Map())
                    });
                }
                catch (invokeErr) {
                    const errorMessage = this.log.error(`Error encountered updating profile of type ${this.profileType} ` +
                        ` with custom update profile handler ` +
                        `("${profileConfig.updateProfileFromArgumentsHandler}"):` +
                        invokeErr.message);
                    throw new error_1.ImperativeError({
                        msg: errorMessage,
                        causeErrors: [invokeErr],
                        stack: invokeErr.stack
                    });
                }
                // zeroth response object is specified to be
                // the finalized profile
                const finishedProfile = response.buildJsonResponse().data;
                this.insertDependenciesIntoProfileFromCLIArguments(newArguments, finishedProfile);
                return finishedProfile;
            }
            else {
                this.log.debug("No custom update profile handler was specified. Building profile from CLI arguments");
                yield this.insertCliArgumentsIntoProfile(newArguments, newProfile);
                if (merge) {
                    this.log.debug("Merging new profile created from CLI arguments with existing profile");
                    newProfile = this.mergeProfiles(oldProfile, newProfile);
                }
                return newProfile;
            }
        });
    }
    /**
     * Take command line arguments from the user and create a profile from them using the schema and configuration for
     * the profile type
     * @param {yargs.Arguments} profileArguments - CLI arguments specified by the user
     * @param {IProfile} starterProfile - the profile with name and type to use to start the profile creation
     * @returns {Promise<IProfile>} profile which provides the finished profile on fulfill
     */
    createProfileFromCommandArguments(profileArguments, starterProfile) {
        return __awaiter(this, void 0, void 0, function* () {
            const profileConfig = this.profileTypeConfiguration;
            if (!util_1.isNullOrUndefined(profileConfig.createProfileFromArgumentsHandler)) {
                const response = new CommandResponse_1.CommandResponse({ silent: true, args: profileArguments });
                let handler;
                try {
                    const commandHandler = require(profileConfig.createProfileFromArgumentsHandler);
                    handler = new commandHandler.default();
                }
                catch (e) {
                    const errorMessage = this.log.error(`Error encountered loading custom create profile handler ` +
                        `${profileConfig.createProfileFromArgumentsHandler}:\n` + +e.message);
                    throw new error_1.ImperativeError({
                        msg: errorMessage,
                        causeErrors: [e],
                        stack: e.stack
                    });
                }
                try {
                    yield handler.process({
                        arguments: CliUtils_1.CliUtils.buildBaseArgs(profileArguments),
                        response,
                        fullDefinition: undefined,
                        definition: undefined,
                        profiles: new CommandProfiles_1.CommandProfiles(new Map())
                    });
                }
                catch (invokeErr) {
                    const errorMessage = this.log.error("Error encountered building new profile with custom create profile handler:" + invokeErr.message);
                    throw new error_1.ImperativeError({
                        msg: errorMessage,
                        causeErrors: [invokeErr],
                        stack: invokeErr.stack
                    });
                }
                // zeroth response object is specified to be
                // the finalized profile
                const finishedProfile = response.buildJsonResponse().data;
                this.insertDependenciesIntoProfileFromCLIArguments(profileArguments, finishedProfile);
                return finishedProfile;
            }
            else {
                const profile = {};
                // default case - no custom handler
                // build profile object directly from command arguments
                yield this.insertCliArgumentsIntoProfile(profileArguments, profile);
                this.insertDependenciesIntoProfileFromCLIArguments(profileArguments, profile);
                return profile;
            }
        });
    }
    /**
     * Default style of building of profile fields to option definitions defined in the schema
     * Will only work if there is a one-to-one option definition mapping for schema fields
     * @param {yargs.Arguments} args - the arguments specified by the user
     * @param {IProfile} profile -  the profile so far, which will be updated
     */
    insertCliArgumentsIntoProfile(args, profile) {
        return __awaiter(this, void 0, void 0, function* () {
            /**
             * Helper routine to find nested properties
             * @param {Object} property - profile property
             * @param {ICommandProfileProperty} property - profile property
             * @param {string} propertyNamePath - Dot notation path of a property (e.g. my.nested.property)
             */
            const findOptions = (property, propertyNamePath) => __awaiter(this, void 0, void 0, function* () {
                if (!util_1.isNullOrUndefined(property.optionDefinition)) {
                    // once we reach a property with an option definition,
                    // we now have the complete path to the property
                    // so we will set the value on the property from the profile
                    this.log.debug("Setting profile field %s from command line option %s", propertyNamePath, property.optionDefinition.name);
                    return args[property.optionDefinition.name];
                }
                if (!util_1.isNullOrUndefined(property.properties)) {
                    const tempProperties = {};
                    for (const childPropertyName of Object.keys(property.properties)) {
                        tempProperties[childPropertyName] =
                            yield findOptions(property.properties[childPropertyName], propertyNamePath + "." + childPropertyName);
                    }
                    return tempProperties;
                }
                return null;
            });
            for (const propertyName of Object.keys(this.profileTypeConfiguration.schema.properties)) {
                profile[propertyName] =
                    yield findOptions(this.profileTypeConfiguration.schema.properties[propertyName], propertyName);
            }
        });
    }
    /**
     * Build the "dependencies" field of a profile object from command line arguments
     * @param {yargs.Arguments} args - the command line arguments from the user
     * @param {IProfile} profile - the profile object so far.
     */
    insertDependenciesIntoProfileFromCLIArguments(args, profile) {
        if (!util_1.isNullOrUndefined(this.profileTypeConfiguration.dependencies)) {
            const dependencies = [];
            for (const dependency of this.profileTypeConfiguration.dependencies) {
                const optionName = profiles_1.ProfileUtils.getProfileOption(dependency.type);
                if (!util_1.isNullOrUndefined(args[optionName])) {
                    const dependentProfileName = args[optionName];
                    this.log.debug("Inserting dependency profile named \"%s\" of type \"%s\"", dependentProfileName, dependency.type);
                    dependencies.push({
                        type: dependency.type,
                        name: dependentProfileName
                    });
                }
            }
            profile.dependencies = dependencies;
        }
    }
}
exports.CliProfileManager = CliProfileManager;
//# sourceMappingURL=CliProfileManager.js.map