"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../../constants");
const path_1 = require("path");
const error_1 = require("../../error");
const EnvironmentalVariableSettings_1 = require("../../imperative/src/env/EnvironmentalVariableSettings");
/**
 * This class is used to contain all configuration being set by Imperative.
 * It is a singleton and should be accessed via ImperativeConfig.instance.
 */
class ImperativeConfig {
    constructor() {
        /**
         * This parameter is used as the container of all loaded configuration for
         * Imperative.
         */
        this.mLoadedConfig = null;
        /**
         * This parameter is used to contain the caller location of imperative configuration file.
         */
        this.mCallerLocation = null;
    }
    /**
     * Gets a single instance of the PluginIssues. On the first call of
     * ImperativeConfig.instance, a new Plugin Issues object is initialized and returned.
     * Every subsequent call will use the one that was first created.
     *
     * @returns {ImperativeConfig} The newly initialized PMF object.
     */
    static get instance() {
        if (this.mInstance == null) {
            this.mInstance = new ImperativeConfig();
        }
        return this.mInstance;
    }
    /**
     * Set the caller location.
     * @param {string} location new location to be updated with
     */
    set callerLocation(location) {
        this.mCallerLocation = location;
    }
    /**
     * Return file location of imperative configuration file.
     * @returns {streturnsring} - location of configuration file
     */
    get callerLocation() {
        return this.mCallerLocation;
    }
    /**
     * Set the loaded config data.
     * @param {IImperativeConfig} config to be set.
     */
    set loadedConfig(config) {
        this.mLoadedConfig = config;
    }
    /**
     * Retrieve the loaded config (if init has
     * @returns {IImperativeConfig} - the config that has been loaded, if any
     */
    get loadedConfig() {
        return this.mLoadedConfig;
    }
    /**
     * Set our root command name.
     * @param rootCommandName - The name of our calling CLI's command.
     */
    set rootCommandName(rootCommandName) {
        this.mRootCommandName = rootCommandName;
    }
    /**
     * Get our root command name.
     * @returns The name of our calling CLI's command.
     */
    get rootCommandName() {
        return this.mRootCommandName;
    }
    /**
     * Retrieve the host package name from which imperative was called.
     */
    get hostPackageName() {
        if (!this.mHostPackageName) {
            this.mHostPackageName = this.callerPackageJson.name;
        }
        return this.mHostPackageName;
    }
    /**
     * Retrieve the package name of the imperative application.
     */
    get imperativePackageName() {
        if (!this.mImperativePackageName) {
            this.mImperativePackageName = require(path_1.join(__dirname, "../../../package.json")).name;
        }
        return this.mImperativePackageName;
    }
    /**
     * Parses the package.json file and searches for the symlink name used under "bin".
     * @returns {string} - return bin symlink name if present, otherwise null
     */
    findPackageBinName() {
        const pkg = this.callerPackageJson;
        if (typeof pkg.bin === "string") {
            return pkg.name;
        }
        else if (typeof pkg.bin === "object") {
            return Object.keys(pkg.bin).pop();
        }
        return null;
    }
    /**
     * Return the cli Home path.
     * @return {string} path to cli Home.
     */
    get cliHome() {
        const settings = EnvironmentalVariableSettings_1.EnvironmentalVariableSettings.read(this.loadedConfig.envVariablePrefix || this.loadedConfig.name);
        if (settings.cliHome.value != null) {
            return settings.cliHome.value;
        }
        return this.loadedConfig.defaultHome;
    }
    /**
     * Return profile Directory.
     * @return {string} profile directory.
     */
    get profileDir() {
        return this.loadedConfig.defaultHome + constants_1.Constants.PROFILES_DIR + "/";
    }
    /**
     * Return package.json of the imperative user
     * @returns {any} - package.json file of caller
     */
    get callerPackageJson() {
        return this.getCallerFile("package.json");
    }
    /**
     * Require a file from a project using imperative accounting for imperative being contained
     * separately from the current implementers directory.
     * @param {string} file - the file to require from project using imperative
     */
    getCallerFile(file) {
        // try to locate the file using find-up first
        let findupErr;
        try {
            const filePath = require("find-up").sync(file, { cwd: ImperativeConfig.instance.callerLocation });
            return require(filePath);
        }
        catch (e) {
            // couldn't locate using find-up, try to require directly
            findupErr = e;
        }
        // if we couldn't find the file path through find-up, try requiring the string directly
        try {
            return require(file);
        }
        catch (e) {
            e.message = "Could not locate the specified module through requiring directly, nor through " +
                "searching the directories above " + this.callerLocation +
                ". 'require()' error message: " + e.message +
                " \n 'find-up' (directory search) error message:" + findupErr.message;
            throw new error_1.ImperativeError({ msg: e.message });
        }
    }
}
/**
 * This is the variable that stores the specific instance of Imperative Config.
 * Defined as static so that it can be accessed from anywhere.
 */
ImperativeConfig.mInstance = null;
exports.ImperativeConfig = ImperativeConfig;
//# sourceMappingURL=ImperativeConfig.js.map