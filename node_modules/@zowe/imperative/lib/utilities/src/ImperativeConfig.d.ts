import { IImperativeConfig } from "../../imperative/src/doc/IImperativeConfig";
/**
 * This class is used to contain all configuration being set by Imperative.
 * It is a singleton and should be accessed via ImperativeConfig.instance.
 */
export declare class ImperativeConfig {
    /**
     * This is the variable that stores the specific instance of Imperative Config.
     * Defined as static so that it can be accessed from anywhere.
     */
    private static mInstance;
    /**
     * This parameter is used as the container of all loaded configuration for
     * Imperative.
     */
    private mLoadedConfig;
    /**
     * This parameter is used to contain the caller location of imperative configuration file.
     */
    private mCallerLocation;
    /**
     * This is the package name of the host application. It will only be set once accessed to
     * lessen loads to the host package.json.
     */
    private mHostPackageName;
    /**
     * This is the name of our imperative package. It will only be set once accessed to
     * lessen loads to the imperative package.json.
     *
     * It isn't hardcoded so that the name of our package can change without affecting
     * modules dependent on it.
     */
    private mImperativePackageName;
    /**
     * This is our calling CLI's command name (taken from package.json: bin).
     */
    private mRootCommandName;
    /**
     * Gets a single instance of the PluginIssues. On the first call of
     * ImperativeConfig.instance, a new Plugin Issues object is initialized and returned.
     * Every subsequent call will use the one that was first created.
     *
     * @returns {ImperativeConfig} The newly initialized PMF object.
     */
    static readonly instance: ImperativeConfig;
    /**
     * Set the caller location.
     * @param {string} location new location to be updated with
     */
    /**
    * Return file location of imperative configuration file.
    * @returns {streturnsring} - location of configuration file
    */
    callerLocation: string;
    /**
     * Set the loaded config data.
     * @param {IImperativeConfig} config to be set.
     */
    /**
    * Retrieve the loaded config (if init has
    * @returns {IImperativeConfig} - the config that has been loaded, if any
    */
    loadedConfig: IImperativeConfig;
    /**
     * Set our root command name.
     * @param rootCommandName - The name of our calling CLI's command.
     */
    /**
    * Get our root command name.
    * @returns The name of our calling CLI's command.
    */
    rootCommandName: string;
    /**
     * Retrieve the host package name from which imperative was called.
     */
    readonly hostPackageName: string;
    /**
     * Retrieve the package name of the imperative application.
     */
    readonly imperativePackageName: string;
    /**
     * Parses the package.json file and searches for the symlink name used under "bin".
     * @returns {string} - return bin symlink name if present, otherwise null
     */
    findPackageBinName(): string;
    /**
     * Return the cli Home path.
     * @return {string} path to cli Home.
     */
    readonly cliHome: string;
    /**
     * Return profile Directory.
     * @return {string} profile directory.
     */
    readonly profileDir: string;
    /**
     * Return package.json of the imperative user
     * @returns {any} - package.json file of caller
     */
    readonly callerPackageJson: any;
    /**
     * Require a file from a project using imperative accounting for imperative being contained
     * separately from the current implementers directory.
     * @param {string} file - the file to require from project using imperative
     */
    getCallerFile(file: string): any;
}
