"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const DeepMerge = require("deepmerge");
const fs_1 = require("fs");
const logger_1 = require("../../logger");
const JSONSettingsFilePersistence_1 = require("./persistance/JSONSettingsFilePersistence");
const io_1 = require("../../io");
const error_1 = require("../../error");
/**
 * This class represents settings for an Imperative CLI application that can be configured
 * by an end user by modifying a settings file. Settings are stored in {@link AppSettings#settings}
 * in a format specified by {@link ISettingsFile}.
 */
class AppSettings {
    /**
     * Initialize
     * @param settingsFile The settings file to load from
     * @param defaults {@link ISettingsFile} Settings with default values
     */
    static initialize(settingsFile, defaults) {
        if (AppSettings.mInstance) {
            const { SettingsAlreadyInitialized } = require("./errors/index");
            throw new SettingsAlreadyInitialized();
        }
        const persistence = new JSONSettingsFilePersistence_1.JSONSettingsFilePersistence(settingsFile);
        let settings = {};
        try {
            logger_1.Logger.getImperativeLogger().trace(`Attempting to load settings file: ${settingsFile}`);
            settings = persistence.read();
        }
        catch (up) {
            if (!fs_1.existsSync(settingsFile)) {
                logger_1.Logger.getImperativeLogger().trace("Executing missing file recovery.");
                io_1.IO.createDirsSyncFromFilePath(settingsFile);
                persistence.write(defaults);
            }
            else {
                logger_1.Logger.getImperativeLogger().error("Unable to recover from load failure");
                logger_1.Logger.getImperativeLogger().error(up.toString());
                throw up;
            }
        }
        const initialSettings = DeepMerge(defaults, settings);
        AppSettings.mInstance = new AppSettings(persistence, initialSettings);
        logger_1.Logger.getImperativeLogger().trace("Settings were loaded");
        logger_1.Logger.getImperativeLogger().trace("Loaded Settings:");
        logger_1.Logger.getImperativeLogger().trace(initialSettings);
        return AppSettings.mInstance;
    }
    /**
     *  Constructs a new settings object
     *
     * @param persistence
     * @param initial Initial settings object
     */
    constructor(persistence, initial) {
        this.persistence = persistence;
        this.settings = initial;
    }
    /**
     * Get the singleton instance of the app settings object that was initialized
     * within the {@link AppSettings.initialize} function.
     *
     * @returns A singleton AppSettings object
     *
     * @throws {@link SettingsNotInitialized} When the settings singleton has not been initialized.
     */
    static get instance() {
        if (AppSettings.mInstance == null) {
            // Throw an error imported at runtime so that we minimize file that get included
            // on startup.
            const { SettingsNotInitialized } = require("./errors/index");
            throw new SettingsNotInitialized();
        }
        return AppSettings.mInstance;
    }
    /**
     * @returns true if the app settings have been initialized
     */
    static get initialized() {
        return !(this.mInstance == null);
    }
    /**
     * Set a settings option and save it to the settings file.
     * @param namespace {@link ISettingsFile}
     * @param key Name of a setting option to set
     * @param value
     */
    set(namespace, key, value) {
        this.settings[namespace][key] = value;
        this.flush();
    }
    /**
     * Get a value of settings option
     * @param namespace {@link ISettingsFile}
     * @param key Name of a setting option to set
     */
    get(namespace, key) {
        if (this.settings[namespace]) {
            return this.settings[namespace][key];
        }
        throw new error_1.ImperativeError({ msg: `Namespace ${namespace} does not exist` });
    }
    /**
     * Get a member of ISettingsFile of specified namespace
     * @param namespace
     */
    getNamespace(namespace) {
        return this.settings[namespace];
    }
    /**
     * Get settings
     */
    getSettings() {
        return this.settings;
    }
    /**
     * Writes settings to the file
     */
    flush() {
        try {
            this.persistence.write(this.settings);
        }
        catch (err) {
            logger_1.Logger.getImperativeLogger().error("Unable to save settings");
            logger_1.Logger.getImperativeLogger().error(err.toString());
            throw err;
        }
    }
}
exports.AppSettings = AppSettings;
//# sourceMappingURL=AppSettings.js.map