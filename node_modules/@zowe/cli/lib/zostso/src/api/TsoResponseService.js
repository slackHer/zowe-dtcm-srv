"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const imperative_1 = require("@zowe/imperative");
const TsoValidator_1 = require("./TsoValidator");
/**
 * Filter responses from z/OSMF
 * @export
 * @class TsoResponseService
 */
class TsoResponseService {
    /**
     * Populates start and stop commands response with z/OSMF response details
     * @param {IZosmfTsoResponse} zosmfResponse -  z/OSMF response object, @see {IZosmfTsoResponse}
     * @returns {IStartStopResponse} populated object with type of IStartStopResponse, @see {IStartStopResponse}
     * @memberOf TsoResponseService
     */
    static populateStartAndStop(zosmfResponse) {
        TsoValidator_1.TsoValidator.validateStartZosmfResponse(zosmfResponse);
        const startResponse = {
            success: false,
            zosmfTsoResponse: zosmfResponse,
            servletKey: zosmfResponse.servletKey,
        };
        if (util_1.isNullOrUndefined(zosmfResponse.servletKey) && zosmfResponse.msgData) {
            startResponse.failureResponse = new imperative_1.ImperativeError({
                msg: zosmfResponse.msgData[0].messageText
            });
        }
        else {
            startResponse.success = true;
        }
        return startResponse;
    }
    /**
     * Populates start and stop commands response with z/OSMF response details
     * @param {IZosmfTsoResponse} zosmfResponse -  z/OSMF response object, @see {IZosmfTsoResponse}
     * @param {ICollectedResponses} collectedResponses -  collected z/OSMF responses object, @see {ICollectedResponses}
     * @returns {IStartStopResponse} populated object with type of IStartStopResponse, @see {IStartStopResponse}
     * @memberOf TsoResponseService
     */
    static populateStartAndStopCollectAll(zosmfResponse, collectedResponses) {
        TsoValidator_1.TsoValidator.validateStartZosmfResponse(zosmfResponse);
        const startResponse = {
            success: false,
            zosmfTsoResponse: zosmfResponse,
            collectedResponses: util_1.isNullOrUndefined(collectedResponses) ? null : collectedResponses.tsos,
            servletKey: zosmfResponse.servletKey,
            messages: util_1.isNullOrUndefined(collectedResponses) ? "" : collectedResponses.messages
        };
        if (util_1.isNullOrUndefined(zosmfResponse.servletKey) && zosmfResponse.msgData) {
            startResponse.failureResponse = new imperative_1.ImperativeError({
                msg: zosmfResponse.msgData[0].messageText
            });
        }
        else {
            startResponse.success = true;
        }
        return startResponse;
    }
    /**
     * Populates ping command response with z/OSMF response details
     * @param {IZosmfPingResponse} zosmfResponse -  z/OSMF response object, @see {IZosmfPingResponse}
     * @returns {PingResponse} populated object with type of IPingResponse
     * @memberOf TsoResponseService
     */
    static populatePing(zosmfResponse) {
        TsoValidator_1.TsoValidator.validatePingZosmfResponse(zosmfResponse);
        const PingResponse = {
            success: false,
            zosmfPingResponse: null,
            servletKey: null,
        };
        if (!util_1.isNullOrUndefined(zosmfResponse.servletKey)) {
            PingResponse.success = true;
            PingResponse.zosmfPingResponse = zosmfResponse;
            PingResponse.servletKey = zosmfResponse.servletKey;
        }
        return PingResponse;
    }
}
exports.TsoResponseService = TsoResponseService;
//# sourceMappingURL=TsoResponseService.js.map