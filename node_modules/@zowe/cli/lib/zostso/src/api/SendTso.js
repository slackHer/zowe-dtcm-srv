"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const imperative_1 = require("@zowe/imperative");
const rest_1 = require("../../../rest");
const util_1 = require("util");
const TsoValidator_1 = require("./TsoValidator");
const TsoConstants_1 = require("./TsoConstants");
/**
 * Class to handle sending data to TSO
 * @class SendTso
 */
class SendTso {
    /**
     * API method to send data to already started TSO address space, but will read TSO data until a PROMPT is reached.
     * @param {AbstractSession} session - z/OSMF connection info
     * @param {string} servletKey - servlet key returned from a successful start
     * @param {string} data - data to send to the TSO address space.
     * @returns {Promise<ISendResponse>} SendTso response object, @see {ISendResponse}
     * @memberof SendTso
     */
    static sendDataToTSOCollect(session, servletKey, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const putResponse = yield SendTso.sendDataToTSOCommon(session, { servletKey, data });
            TsoValidator_1.TsoValidator.validateErrorMessageFromZosmf(putResponse);
            const responses = yield SendTso.getAllResponses(session, putResponse);
            return SendTso.createResponse(responses.tsos, responses.messages);
        });
    }
    /**
     * API method to send data to already started TSO address space
     * @param {AbstractSession} session - z/OSMF connection info
     * @param {IStartTsoParms} commandParams - object with required parameters, @see {ISendTsoParms}
     * @returns {Promise<IZosmfTsoResponse>} - z/OSMF response object, @see {IZosmfTsoResponse}
     * @memberof SendTso
     */
    static sendDataToTSOCommon(session, commandParams) {
        return __awaiter(this, void 0, void 0, function* () {
            TsoValidator_1.TsoValidator.validateSession(session);
            TsoValidator_1.TsoValidator.validateNotEmptyString(commandParams.servletKey, TsoConstants_1.noServletKeyInput.message);
            TsoValidator_1.TsoValidator.validateNotEmptyString(commandParams.data, TsoConstants_1.noDataInput.message);
            const parameters = "/" + TsoConstants_1.TsoConstants.RES_START_TSO + "/" + commandParams.servletKey + TsoConstants_1.TsoConstants.RES_DONT_READ_REPLY;
            const jobObj = { "TSO RESPONSE": { VERSION: "0100", DATA: commandParams.data } };
            return rest_1.ZosmfRestClient.putExpectJSON(session, TsoConstants_1.TsoConstants.RESOURCE + parameters, [rest_1.ZosmfHeaders.X_CSRF_ZOSMF_HEADER, imperative_1.Headers.APPLICATION_JSON], jobObj);
        });
    }
    /**
     * API method is used to get response data from a TSO address space.
     * @param {AbstractSession} session - z/OSMF connection info
     * @param {String} servletKey - servlet key of address space
     * @returns {Promise<IZosmfTsoResponse>} - z/OSMF response object, @see {IZosmfTsoResponse}
     * @memberof SendTso
     */
    static getDataFromTSO(session, servletKey) {
        return __awaiter(this, void 0, void 0, function* () {
            TsoValidator_1.TsoValidator.validateSession(session);
            const parameters = "/" + TsoConstants_1.TsoConstants.RES_START_TSO + "/" + servletKey;
            return rest_1.ZosmfRestClient.getExpectJSON(session, TsoConstants_1.TsoConstants.RESOURCE + parameters, [rest_1.ZosmfHeaders.X_CSRF_ZOSMF_HEADER, imperative_1.Headers.APPLICATION_JSON]);
        });
    }
    /**
     * Collects responses from address space until it reaches prompt
     * @param {AbstractSession} session - z/OSMF connection info
     * @param {IZosmfTsoResponse} tso - object from first API call from witch responses are needed
     * @returns {Promise<ICollectedResponses>} - CollectedResponses response object, @see {ICollectedResponses}
     * @memberof SendTso
     */
    static getAllResponses(session, tso) {
        return __awaiter(this, void 0, void 0, function* () {
            let done = false;
            const tsos = [];
            tsos.push(tso);
            let messages = "";
            while (!done) {
                if (!util_1.isNullOrUndefined(tso.tsoData)) {
                    tso.tsoData.forEach((data) => {
                        if (data[TsoConstants_1.TsoConstants.TSO_MESSAGE]) {
                            messages += (data[TsoConstants_1.TsoConstants.TSO_MESSAGE].DATA + "\n");
                        }
                        else if (data[TsoConstants_1.TsoConstants.TSO_PROMPT]) {
                            // handle case where we get a PROMPT but no data has been accumulated yet
                            if (messages !== "") {
                                done = true;
                            }
                            else {
                                // TSO PROMPT reached without getting any data, retrying
                            }
                        }
                    });
                }
                if (!done) {
                    tso = yield SendTso.getDataFromTSO(session, tso.servletKey);
                    TsoValidator_1.TsoValidator.validateErrorMessageFromZosmf(tso);
                }
            }
            return {
                tsos,
                messages
            };
        });
    }
    /**
     * Creates ISendResponse object and fills with data
     * @param {IZosmfTsoResponse[]} allResponses - array of all collected responses
     * @param {string} messages - concatenated messages from responses
     * @returns {ISendResponse} - SendTso response object, @see {ISendResponse}
     * @memberof SendTso
     */
    static createResponse(allResponses, messages) {
        return {
            success: true,
            zosmfResponse: allResponses,
            commandResponse: messages
        };
    }
}
exports.SendTso = SendTso;
//# sourceMappingURL=SendTso.js.map