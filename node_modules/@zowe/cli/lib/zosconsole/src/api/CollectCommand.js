"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const imperative_1 = require("@zowe/imperative");
const rest_1 = require("../../../rest");
const util_1 = require("util");
const ConsoleValidator_1 = require("./ConsoleValidator");
const ConsoleConstants_1 = require("./ConsoleConstants");
const ConsoleResponseService_1 = require("./ConsoleResponseService");
/**
 * Get the response to a command that was issued asynchronously with the Issue Command service
 * @export
 * @class CollectCommand
 */
class CollectCommand {
    /**
     * Collect any messages related to the synchronous command response key provided
     * @static
     * @param {AbstractSession} session representing connection to this api
     * @param {string} consoleName name of the EMCS console that is used to issue the command
     * @param {string} commandResponseKey command response key from the Issue Command request
     * @returns {Promise<IZosmfIssueResponse>} command response on resolve, @see {IZosmfIssueResponse}
     * @memberof CollectCommand
     */
    static collectCommon(session, consoleName, commandResponseKey) {
        ConsoleValidator_1.ConsoleValidator.validateCollectCommonParms(session, consoleName, commandResponseKey);
        return rest_1.ZosmfRestClient.getExpectJSON(session, CollectCommand.getResource(consoleName, commandResponseKey));
    }
    /**
     * Collect any messages (from default console) related to the synchronous command response key provided
     * @static
     * @param {AbstractSession} session representing connection to this api
     * @param {string} commandResponseKey command response key from the Issue Command request
     * @return {Promise<IZosmfCollectResponse>} command response on resolve, @see {IZosmfCollectResponse}
     * @memberof CollectCommand
     */
    static collectDefConsoleCommon(session, commandResponseKey) {
        return CollectCommand.collectCommon(session, ConsoleConstants_1.ConsoleConstants.RES_DEF_CN, commandResponseKey);
    }
    /**
     * Collect any messages related to the synchronous command response key provided and collect them into IConsoleResponse
     *
     * To control additional collection and other behaviors, populate the ICollectParms object according
     * to your needs (see ICollectParms for details).
     * @static
     * @param {AbstractSession} session representing connection to this api
     * @param {ICollectParms} parms console collect parameters, @see {ICollectParms}
     * @param {IConsoleResponse} response response from previous command (if present), @see {IConsoleResponse}
     * @return {Promise<IConsoleResponse>} command response on resolve, @see {IConsoleResponse}
     * @memberof CollectCommand
     */
    static collect(session, parms, response) {
        return __awaiter(this, void 0, void 0, function* () {
            ConsoleValidator_1.ConsoleValidator.validateCollectParms(session, parms);
            if (util_1.isNullOrUndefined(response)) {
                response = ConsoleResponseService_1.ConsoleResponseService.getEmptyConsoleResponse();
            }
            const consoleName = util_1.isNullOrUndefined(parms.consoleName) ? ConsoleConstants_1.ConsoleConstants.RES_DEF_CN : parms.consoleName;
            const maxFollowUpAttempts = CollectCommand.getFollowUpAttempts(parms);
            const timeout = CollectCommand.getTimeout(parms);
            let collectResponse;
            let followUpCounter = maxFollowUpAttempts;
            do {
                imperative_1.Logger.getImperativeLogger().info(imperative_1.TextUtils.formatMessage(ConsoleConstants_1.collectProcessingDetails.message, {
                    timer: timeout,
                    counter: followUpCounter
                }));
                try {
                    if (timeout > 0) {
                        yield new Promise((doNothing) => setTimeout(doNothing, timeout));
                    }
                    collectResponse = yield CollectCommand.collectCommon(session, consoleName, parms.commandResponseKey);
                    response = ConsoleResponseService_1.ConsoleResponseService.populate(collectResponse, response, parms.processResponses);
                    if (ConsoleResponseService_1.ConsoleResponseService.isLastZosmfResponseEmpty(response)) {
                        followUpCounter--;
                        imperative_1.Logger.getImperativeLogger().info(ConsoleConstants_1.decreaseCounter.message);
                    }
                    else {
                        followUpCounter = maxFollowUpAttempts;
                        imperative_1.Logger.getImperativeLogger().info(ConsoleConstants_1.resetCounter.message);
                    }
                }
                catch (error) {
                    response = ConsoleResponseService_1.ConsoleResponseService.populateError(error, response);
                    followUpCounter = 0;
                }
            } while (followUpCounter > 0 || response.keywordDetected);
            return response;
        });
    }
    /**
     * Get resource path for collect command
     * @param {string} consoleName name of the EMCS console that is used to issue the command
     * @param {string} commandResponseKey command response key from the Issue Command request
     * @return {string} resource path
     * @memberof CollectCommand
     */
    static getResource(consoleName, commandResponseKey) {
        return ConsoleConstants_1.ConsoleConstants.RESOURCE + "/" + consoleName + ConsoleConstants_1.ConsoleConstants.SOL_MSGS + "/" + commandResponseKey;
    }
    /**
     *
     * @param {ICollectParms} parms parameters for collect command
     * @return {number}
     */
    static getFollowUpAttempts(parms) {
        return util_1.isNullOrUndefined(parms) || util_1.isNullOrUndefined(parms.followUpAttempts) ? ConsoleConstants_1.ConsoleConstants.DEFAULT_FOLLOWUP_ATTEMPTS
            : parms.followUpAttempts;
    }
    /**
     * @static
     * @param {ICollectParms} parms console collect parameters, @see {ICollectParms}s
     * @return {number} timeout in milliseconds or default value
     * @memberof CollectCommand
     */
    static getTimeout(parms) {
        return util_1.isNullOrUndefined(parms) || util_1.isNullOrUndefined(parms.waitToCollect) ? ConsoleConstants_1.ConsoleConstants.DEFAULT_TIMEOUT
            : parms.waitToCollect * CollectCommand.TO_SECONDS;
    }
}
CollectCommand.TO_SECONDS = 1000;
exports.CollectCommand = CollectCommand;
//# sourceMappingURL=CollectCommand.js.map