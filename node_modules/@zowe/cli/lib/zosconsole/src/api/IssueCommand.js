"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const imperative_1 = require("@zowe/imperative");
const rest_1 = require("../../../rest");
const util_1 = require("util");
const ConsoleValidator_1 = require("./ConsoleValidator");
const ConsoleConstants_1 = require("./ConsoleConstants");
const ConsoleResponseService_1 = require("./ConsoleResponseService");
const CollectCommand_1 = require("./CollectCommand");
/**
 * Issue MVS Console commands by using a system console
 * @export
 * @class IssueCommand
 */
class IssueCommand {
    /**
     * Issue an MVS console command, returns "raw" z/OSMF response
     * @static
     * @param {AbstractSession} session representing connection to this api
     * @param {string} consoleName name of the EMCS console that is used to issue the command
     * @param {IZosmfIssueParms} commandParms synchronous console issue parameters, @see {IZosmfIssueParms}
     * @return {Promise<IZosmfIssueResponse>} command response on resolve, @see {IZosmfIssueResponse}
     * @memberof IssueCommand
     */
    static issueCommon(session, consoleName, commandParms) {
        ConsoleValidator_1.ConsoleValidator.validateCommonParms(session, consoleName, commandParms);
        return rest_1.ZosmfRestClient.putExpectJSON(session, IssueCommand.getResource(consoleName), [imperative_1.Headers.APPLICATION_JSON], commandParms);
    }
    /**
     * Issue an MVS console command in default console, returns "raw" z/OSMF response
     * @static
     * @param {AbstractSession} session representing connection to this api
     * @param {IZosmfIssueParms} commandParms synchronous console issue parameters, @see {IZosmfIssueParms}
     * @return {Promise<IZosmfIssueResponse>} command response on resolve, @see {IZosmfIssueResponse}
     * @memberof IssueCommand
     */
    static issueDefConsoleCommon(session, commandParms) {
        return IssueCommand.issueCommon(session, ConsoleConstants_1.ConsoleConstants.RES_DEF_CN, commandParms);
    }
    /**
     * Issue an MVS console command command synchronously - meaning solicited (direct command responses) are gathered
     * immediately after the command is issued. However, after (according to the z/OSMF REST API documentation)
     * approximately 3 seconds the response will be returned.
     * @static
     * @param {AbstractSession} session representing connection to this api
     * @param {IIssueParms} parms console issue parameters, @see {IIssueParms}
     * @return {Promise<IConsoleResponse>} command response on resolve, @see {IConsoleResponse}
     * @memberof IssueCommand
     */
    static issue(session, parms) {
        return __awaiter(this, void 0, void 0, function* () {
            ConsoleValidator_1.ConsoleValidator.validateIssueParms(session, parms);
            const consoleName = util_1.isNullOrUndefined(parms.consoleName) ? ConsoleConstants_1.ConsoleConstants.RES_DEF_CN : parms.consoleName;
            const commandParms = IssueCommand.buildZosmfConsoleApiParameters(parms);
            let response = ConsoleResponseService_1.ConsoleResponseService.getEmptyConsoleResponse();
            const resp = yield IssueCommand.issueCommon(session, consoleName, commandParms);
            response = ConsoleResponseService_1.ConsoleResponseService.populate(resp, response, parms.processResponses);
            return response;
        });
    }
    /**
     * Simple issue console command method. Does not accept parameters, so all defaults on the z/OSMF API are taken.
     * @static
     * @param {AbstractSession} session representing connection to this api
     * @param {string} theCommand command to issue
     * @return {Promise<IConsoleResponse>} command response on resolve, @see {IConsoleResponse}
     * @memberof IssueCommand
     */
    static issueSimple(session, theCommand) {
        return __awaiter(this, void 0, void 0, function* () {
            ConsoleValidator_1.ConsoleValidator.validateIssueSimpleParms(session, theCommand);
            const parms = {
                command: theCommand,
                processResponses: true
            };
            return IssueCommand.issue(session, parms);
        });
    }
    /**
     * Issue an MVS console command command synchronously - meaning solicited (direct command responses) are gathered
     * immediately after the command is issued. However, after (according to the z/OSMF REST API documentation)
     * approximately 3 seconds the response will be returned.
     *
     * To control additional collection and other behaviors, populate the ICollectParms object according
     * to your needs (see ICollectParms for details).
     * @static
     * @param {AbstractSession} session representing connection to this api
     * @param {IIssueParms} issueParms console issue parameters, @see {IIssueParms}
     * @param {ICollectParms} collectParms console collect parameters, @see {ICollectParms}
     * @return {Promise<IConsoleResponse>} command response on resolve, @see {IConsoleResponse}
     * @memberof IssueCommand
     */
    static issueAndCollect(session, issueParms, collectParms) {
        return __awaiter(this, void 0, void 0, function* () {
            ConsoleValidator_1.ConsoleValidator.validateCollectParm(collectParms);
            let response = yield IssueCommand.issue(session, issueParms);
            if (response.lastResponseKey && !response.keywordDetected) {
                collectParms.commandResponseKey = response.lastResponseKey;
                response = yield CollectCommand_1.CollectCommand.collect(session, collectParms, response);
            }
            return response;
        });
    }
    /**
     * Get resource path for issue command
     * @static
     * @param {string} consoleName name of the EMCS console that is used to issue the command
     * @return {string} resource path
     * @memberof IssueCommand
     */
    static getResource(consoleName) {
        return ConsoleConstants_1.ConsoleConstants.RESOURCE + "/" + consoleName;
    }
    /**
     * Build IZosmfIssueParms object from provided parameters
     * @static
     * @param {IIssueParms} parms parameters for issue command
     * @return {IZosmfIssueParms} request body, @see {ZosmfConsoleApiParameters}
     * @memberof IssueCommand
     */
    static buildZosmfConsoleApiParameters(parms) {
        ConsoleValidator_1.ConsoleValidator.validateIssueParm(parms);
        const zosmfParms = { cmd: parms.command };
        if (!util_1.isNullOrUndefined(parms.solicitedKeyword)) {
            zosmfParms["sol-key"] = parms.solicitedKeyword;
        }
        if (!util_1.isNullOrUndefined(parms.sysplexSystem)) {
            zosmfParms.system = parms.sysplexSystem;
        }
        if (!util_1.isNullOrUndefined(parms.async)) {
            zosmfParms.async = parms.async;
        }
        return zosmfParms;
    }
}
exports.IssueCommand = IssueCommand;
//# sourceMappingURL=IssueCommand.js.map