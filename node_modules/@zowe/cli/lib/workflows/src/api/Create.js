"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const imperative_1 = require("@zowe/imperative");
const rest_1 = require("../../../rest");
const WorkflowConstants_1 = require("./WorkflowConstants");
const WorkflowValidator_1 = require("./WorkflowValidator");
const util_1 = require("util");
const api_1 = require("../../../zosfiles/src/api");
const path_1 = require("path");
/**
 * Class to handle creation of zOSMF workflow instance
 */
class CreateWorkflow {
    /**
     * copied from ProvisioningService.ts
     * Parsers text with properties in key1=val1,key2=val2 format and returns IInputProperty[]
     * @param {string} propertiesText - required runtime property objects passed as a string.
     * @returns {IPropertiesInput[]} array of properties, @see {IPropertiesInput}
     * @memberof ProvisioningService
     */
    static parseProperties(propertiesText) {
        if (propertiesText === "") {
            return [];
        }
        return propertiesText.split(",").map((property) => {
            const tempArray = property.split("=");
            if (tempArray.length === 2 && tempArray[0].length > 0) {
                return { name: tempArray[0].trim(), value: tempArray[1].trim() };
            }
            else {
                throw new imperative_1.ImperativeError({ msg: `Incorrect properties format: ${propertiesText}` });
            }
        });
    }
    /**
     * Create a zOSMF workflow instance
     * @param {AbstractSession} session                     - z/OSMF connection info
     * @param {string} WorkflowName                         - Name of the workflow that will be created
     * @param {string} WorkflowDefinitionFile               - Full path to USS file or DATASET/MEMBER with xml
     * @param {string} systemName                           - System where the workflow will run
     * @param {string} Owner                                - User ID of the workflow owner.
     * @param {string} VariableInputFile                    - Properties file with pre-specify values for workflow variables
     * @param {string} Variables                            - A list of one or more variables for the workflow.
     * @param {boolean} AssignToOwner                       - Indicates whether the workflow steps are assigned to the workflow owner
     * @param {accessT} AccessType                          - Specifies the access type for the workflow. Public, Restricted or Private.
     * @param {boolean} DeleteCompletedJobs                 - Specifies whether the job is deleted from the JES spool after it completes successfully.
     * @param {string} zOSMFVersion                         - Identifies the version of the zOSMF workflow service.
     * @returns {Promise<ICreatedWorkflow>}
     */
    static createWorkflow(session, WorkflowName, WorkflowDefinitionFile, systemName, Owner, VariableInputFile, Variables, AssignToOwner, AccessType, DeleteCompletedJobs, zOSMFVersion = WorkflowConstants_1.WorkflowConstants.ZOSMF_VERSION) {
        WorkflowValidator_1.WorkflowValidator.validateSession(session);
        WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(zOSMFVersion, WorkflowConstants_1.nozOSMFVersion.message);
        WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(WorkflowName, WorkflowConstants_1.noWorkflowName.message);
        WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(WorkflowDefinitionFile, WorkflowConstants_1.noWorkflowDefinitionFile.message);
        WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(systemName, WorkflowConstants_1.noSystemName.message);
        WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(Owner, WorkflowConstants_1.noOwner.message);
        WorkflowValidator_1.WorkflowValidator.validateOwner(Owner, WorkflowConstants_1.wrongOwner.message);
        if (WorkflowDefinitionFile.charAt(0) === "/" && WorkflowDefinitionFile.charAt(1) === "/") {
            WorkflowDefinitionFile = WorkflowDefinitionFile.substring(1);
        }
        const data = {
            workflowName: WorkflowName,
            workflowDefinitionFile: WorkflowDefinitionFile,
            system: systemName,
            owner: Owner,
            assignToOwner: AssignToOwner,
            accessType: AccessType,
            deleteCompletedJobs: DeleteCompletedJobs,
        };
        if (!util_1.isNullOrUndefined(VariableInputFile)) {
            if (VariableInputFile.charAt(0) === "/" && VariableInputFile.charAt(1) === "/") {
                VariableInputFile = VariableInputFile.substring(1);
            }
            data.variableInputFile = VariableInputFile;
        }
        if (!util_1.isNullOrUndefined(Variables)) {
            data.variables = this.parseProperties(Variables);
        }
        if (util_1.isNullOrUndefined(AssignToOwner)) {
            data.assignToOwner = true;
        }
        if (util_1.isNullOrUndefined(AccessType)) {
            data.accessType = "Public";
        }
        if (util_1.isNullOrUndefined(DeleteCompletedJobs)) {
            data.deleteCompletedJobs = false;
        }
        const resourcesQuery = `${WorkflowConstants_1.WorkflowConstants.RESOURCE}/${zOSMFVersion}/${WorkflowConstants_1.WorkflowConstants.WORKFLOW_RESOURCE}`;
        return rest_1.ZosmfRestClient.postExpectJSON(session, resourcesQuery, [imperative_1.Headers.APPLICATION_JSON], data);
    }
    /**
     * Create a zOSMF workflow instance using local files
     * @param {AbstractSession} session                     - z/OSMF connection info
     * @param {string} WorkflowName                         - Name of the workflow that will be created
     * @param {string} WorkflowDefinitionFile               - Local workflow definition file
     * @param {string} systemName                           - System where the workflow will run
     * @param {string} Owner                                - User ID of the workflow owner.
     * @param {string} VariableInputFile                    - Local properties file with pre-specify values for workflow variables
     * @param {string} Variables                            - A list of one or more variables for the workflow.
     * @param {boolean} AssignToOwner                       - Indicates whether the workflow steps are assigned to the workflow owner
     * @param {accessT} AccessType                          - Specifies the access type for the workflow. Public, Restricted or Private.
     * @param {boolean} DeleteCompletedJobs                 - Specifies whether the job is deleted from the JES spool after it completes successfully.
     * @param {string} zOSMFVersion                         - Identifies the version of the zOSMF workflow service.
     * @param {boolean} keepFiles                           - Identifies if the uploaded uss files should be kept.
     * @param {string} customDir                            - Path to specific USS directory in which to upload the temp files.
     * @returns {Promise<ICreatedWorkflowLocal>}
     */
    static createWorkflowLocal(session, WorkflowName, WorkflowDefinitionFile, systemName, Owner, VariableInputFile, Variables, AssignToOwner, AccessType, DeleteCompletedJobs, keepFiles, customDir, zOSMFVersion = WorkflowConstants_1.WorkflowConstants.ZOSMF_VERSION) {
        return __awaiter(this, void 0, void 0, function* () {
            WorkflowValidator_1.WorkflowValidator.validateSession(session);
            WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(zOSMFVersion, WorkflowConstants_1.nozOSMFVersion.message);
            WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(WorkflowName, WorkflowConstants_1.noWorkflowName.message);
            WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(WorkflowDefinitionFile, WorkflowConstants_1.noWorkflowDefinitionFile.message);
            WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(systemName, WorkflowConstants_1.noSystemName.message);
            WorkflowValidator_1.WorkflowValidator.validateNotEmptyString(Owner, WorkflowConstants_1.noOwner.message);
            WorkflowValidator_1.WorkflowValidator.validateOwner(Owner, WorkflowConstants_1.wrongOwner.message);
            const tempDefinitionFile = CreateWorkflow.getTempFile(session.ISession.user, WorkflowDefinitionFile, customDir);
            yield CreateWorkflow.uploadTempFile(session, WorkflowDefinitionFile, tempDefinitionFile);
            let tempVariableInputFile;
            if (VariableInputFile) {
                tempVariableInputFile = CreateWorkflow.getTempFile(session.ISession.user, VariableInputFile, customDir);
                yield CreateWorkflow.uploadTempFile(session, VariableInputFile, tempVariableInputFile);
            }
            const resp = yield this.createWorkflow(session, WorkflowName, tempDefinitionFile, systemName, Owner, tempVariableInputFile, Variables, AssignToOwner, AccessType, DeleteCompletedJobs, zOSMFVersion);
            if (!keepFiles) {
                resp.failedToDelete = [yield CreateWorkflow.deleteTempFile(session, tempDefinitionFile)];
                if (VariableInputFile) {
                    !resp.failedToDelete[0] ?
                        resp.failedToDelete = [yield CreateWorkflow.deleteTempFile(session, tempVariableInputFile)] :
                        resp.failedToDelete.push(yield CreateWorkflow.deleteTempFile(session, tempVariableInputFile));
                }
            }
            else {
                resp.filesKept = [tempDefinitionFile];
                if (VariableInputFile) {
                    resp.filesKept.push(tempVariableInputFile);
                }
            }
            return resp;
        });
    }
    /**
     * Get a full path with file name for a temporary USS file
     * @param {string} userId                               - User ID to add to the file name.
     * @param {string} localFile                            - Local file name.
     * @param {string} customDir                            - Custom directory.
     * @returns {string}
     */
    static getTempFile(userId, localFile, customDir) {
        let remoteFile;
        if (customDir) {
            remoteFile = customDir + "/" + path_1.basename(localFile);
        }
        else {
            remoteFile = WorkflowConstants_1.WorkflowConstants.tempPath + "/" + userId + Date.now().toString() + path_1.basename(localFile);
        }
        return remoteFile;
    }
    /**
     *  Upload USS files to default dir, or a user specified one
     * @param {AbstractSession} session                     - z/OSMF connection info.
     * @param {string} localFile                            - Local file to upload.
     * @param {string} remoteFile                           - Remote location to upload to.
     * @throws {ImperativeError}                            - In case something goes wrong.
     */
    static uploadTempFile(session, localFile, remoteFile) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield api_1.Upload.fileToUSSFile(session, localFile, remoteFile, true);
            }
            catch (error) {
                throw new imperative_1.ImperativeError({
                    msg: "Failed to create temporary uss file\n" + (error.message) + "\n" + (error.additionalDetails),
                });
            }
        });
    }
    /**
     * Delete USS file
     * @param {AbstractSession} session                     - z/OSMF connection info.
     * @param {string} ussFileName                          - USS file to delete.
     */
    static deleteTempFile(session, ussFileName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let deletableLocation;
                ussFileName.startsWith("/") ? deletableLocation = ussFileName.slice(1) : deletableLocation = ussFileName;
                yield api_1.Delete.ussFile(session, deletableLocation);
            }
            catch (error) {
                return ussFileName;
            }
            return;
        });
    }
}
exports.CreateWorkflow = CreateWorkflow;
//# sourceMappingURL=Create.js.map