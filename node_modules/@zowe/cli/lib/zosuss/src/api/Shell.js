"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const imperative_1 = require("@zowe/imperative");
const ZosUss_messages_1 = require("../api/constants/ZosUss.messages");
const Client = require("ssh2");
// These are needed for authenticationHandler
let authPos = 0;
const authsAllowed = ["none"];
let hasAuthFailed = false;
exports.startCmdFlag = "@@START OF COMMAND@@";
class Shell {
    static executeSsh(session, command, stdoutHandler) {
        const promise = new Promise((resolve, reject) => {
            // These are needed for authenticationHandler
            // The order is critical as this is the order of authentication that will be used.
            if (session.ISshSession.privateKey != null && session.ISshSession.privateKey !== "undefined") {
                authsAllowed.push("publickey");
            }
            if (session.ISshSession.password != null && session.ISshSession.password !== "undefined") {
                authsAllowed.push("password");
            }
            const conn = new Client();
            conn.on("ready", () => {
                conn.shell((err, stream) => {
                    if (err) {
                        throw err;
                    }
                    let dataBuffer = "";
                    let dataToPrint = "";
                    let isUserCommand = false;
                    let rc;
                    stream.on("exit", (exitcode) => {
                        imperative_1.Logger.getAppLogger().debug("Return Code: " + exitcode);
                        rc = exitcode;
                    });
                    stream.on("close", () => {
                        imperative_1.Logger.getAppLogger().debug("SSH connection closed");
                        stdoutHandler("\n");
                        conn.end();
                        resolve(rc);
                    });
                    stream.on("data", (data) => {
                        imperative_1.Logger.getAppLogger().debug("\n[Received data begin]" + data + "[Received data end]\n");
                        dataBuffer += data;
                        if (dataBuffer.includes("\r")) {
                            // when data is not received with complete lines,
                            // slice the last incomplete line and put it back to dataBuffer until it gets the complete line,
                            // rather than print it out right away
                            dataToPrint = dataBuffer.slice(0, dataBuffer.lastIndexOf("\r"));
                            dataBuffer = dataBuffer.slice(dataBuffer.lastIndexOf("\r"));
                            // check startCmdFlag: start printing out data
                            if (dataToPrint.match(new RegExp(`\n${exports.startCmdFlag}`)) || dataToPrint.match(new RegExp("\\$ " + exports.startCmdFlag))) {
                                dataToPrint = dataToPrint.slice(dataToPrint.indexOf(exports.startCmdFlag) + exports.startCmdFlag.length);
                                isUserCommand = true;
                            }
                            if (isUserCommand && dataToPrint.match(new RegExp("\\$ exit"))) {
                                // if exit found, print out stuff before exit, then stop printing out.
                                dataToPrint = dataToPrint.slice(0, dataToPrint.indexOf("$ exit"));
                                stdoutHandler(dataToPrint);
                                dataToPrint = "";
                                isUserCommand = false;
                            }
                            else if (isUserCommand) {
                                // print out the user command result
                                stdoutHandler(dataToPrint);
                                dataToPrint = "";
                            }
                        }
                    });
                    // exit multiple times in case of nested shells
                    stream.write(`export PS1='$ '\necho ${exports.startCmdFlag}\n${command}\n` +
                        `exit $?\nexit $?\nexit $?\nexit $?\nexit $?\nexit $?\nexit $?\nexit $?\n`);
                    stream.end();
                });
            });
            conn.connect({
                host: session.ISshSession.hostname,
                port: session.ISshSession.port,
                username: session.ISshSession.user,
                password: session.ISshSession.password,
                privateKey: (session.ISshSession.privateKey != null && session.ISshSession.privateKey !== "undefined") ?
                    require("fs").readFileSync(session.ISshSession.privateKey) : "",
                passphrase: session.ISshSession.keyPassphrase,
                authHandler: Shell.authenticationHandler,
                readyTimeout: (session.ISshSession.handshakeTimeout != null && session.ISshSession.handshakeTimeout !== undefined) ?
                    session.ISshSession.handshakeTimeout : 0
            });
            conn.on("error", (err) => {
                if (err.message.includes(ZosUss_messages_1.ZosUssMessages.allAuthMethodsFailed.message)) {
                    hasAuthFailed = true;
                    reject(new imperative_1.ImperativeError({
                        msg: ZosUss_messages_1.ZosUssMessages.allAuthMethodsFailed.message
                    }));
                }
                // throw error only when authentication didn't fail.
                else if (!hasAuthFailed && err.message.includes(ZosUss_messages_1.ZosUssMessages.handshakeTimeout.message)) {
                    reject(new imperative_1.ImperativeError({
                        msg: ZosUss_messages_1.ZosUssMessages.handshakeTimeout.message,
                    }));
                }
                else {
                    throw err;
                }
            });
        });
        return promise;
    }
    static executeSshCwd(session, command, cwd, stdoutHandler) {
        return __awaiter(this, void 0, void 0, function* () {
            const cwdCommand = `cd ${cwd} && ${command}`;
            return this.executeSsh(session, cwdCommand, stdoutHandler);
        });
    }
    /**
     * Getter for brightside logger
     * @returns {Logger}
     */
    static get log() {
        return imperative_1.Logger.getAppLogger();
    }
    static authenticationHandler(methodsLeft, partialSuccess, callback) {
        partialSuccess = true;
        if (authPos === authsAllowed.length) {
            return false;
        }
        return authsAllowed[authPos++];
    }
}
exports.Shell = Shell;
//# sourceMappingURL=Shell.js.map