"use strict";
/*!
 * This program and the accompanying materials are made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Copyright Contributors to the Zowe Project.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const pkgUp = require("pkg-up");
const constants_1 = require("../../constants");
const environment_1 = require("../../environment");
// tslint:enable
//////////////////////////////////////////
/////////////// END TYPING ///////////////
//////////////////////////////////////////
/**
 * The manager responsible for the {@link PerformanceApi} created by the current package instance.
 *
 * **NOTE:**
 *
 * This class is not intended to be instantiated directly. It should be accessed
 * through the {@link PerfTiming} variable instantiated by this package. Failure
 * to do so will result in lost metrics in the final file output.
 */
class PerformanceApiManager {
    /**
     * The constructor will instantiate this manager and determine if performance monitoring is
     * enabled.
     *
     * If the monitoring is enabled, it will also calculate the name of the global symbol. Also, if
     * the global symbol has not been instantiated, this manager will be the default one and will
     * be the one responsible for saving all data to the files.
     *
     */
    constructor() {
        // First check if the environment prefix is set to the ENV_ENABLED_KEY value
        if (environment_1.Environment.getValue(PerformanceApiManager.ENV_ENABLED).toUpperCase() === PerformanceApiManager.ENV_ENABLED_KEY) {
            // The environment was set so performance metrics are enabled.
            this.isEnabled = true;
            // Generate the packageUUID
            const pkg = require(pkgUp.sync() || pkgUp.sync(__dirname));
            this.packageUUID = `${pkg.name}@${pkg.version}`;
            // Check if the global scope has been created. If it hasn't been created
            // this is the first manager called so it will become the main manager.
            if (!global[constants_1.GLOBAL_SYMBOL]) {
                // Create the global map on first run
                global[constants_1.GLOBAL_SYMBOL] = new Map();
                process.on("exit", () => this._savePerformanceResults()); // @TODO log any errors that might have been thrown
            }
        }
        else {
            // Performance was not enabled.
            this.isEnabled = false;
        }
    }
    /**
     * Gets the {@link _api}.
     *
     * **NOTE:**
     *
     * It is recommended that calls to the getApi method are contained within an if check to see
     * if performance is enabled. This method will provide the least overhead for when performance
     * is disabled but will add a some overhead when performance is enabled.
     *
     * **NOTE:**
     *
     * If performance is not enabled, this method will still return a {@link PerformanceApi}
     * object and all methods can still be called the same way with performance enabled or disabled.
     * With this in mind, it is not required that calls to this method are wrapped in a check to see
     * if this is enabled, but it is still recommended.
     *
     * @returns The performance api that is managed by this class.
     */
    get api() {
        if (this._api == null) {
            // Defers the import until it is needed, will improve performance when
            // performance api hasn't yet been called.
            const performanceApi = require("../api/PerformanceApi").PerformanceApi;
            this._api = new performanceApi(this);
            // Create a unique entry in the global map
            if (this.isEnabled) {
                this._instanceSymbol = Symbol(this.packageUUID);
                // Save the managedApi in the global space. It has been typed so that
                // changes to the wrapper methods of IPerformanceTools cannot be easily
                // changed.
                global[constants_1.GLOBAL_SYMBOL].set(this._instanceSymbol, this._api);
            }
        }
        // Can guarantee that this will be unique per package instance :)
        return this._api;
    }
    /**
     * Responsible for gathering and saving all metrics present within the
     * environment.
     *
     * This method is only called by `process.on('exit')` defined in the {@link constructor} of the
     * main manager. The nodeTiming and systemInformation portions of the {@link IPerformanceMetrics}
     * object are gathered from the {@link _api} of this manager.
     *
     * Metrics are gathered by examining each API present in the {@link NodeJS.global} object. This
     * design comes from the fact that there could be multiple instances of the PerfTiming package
     * due to how npm dependencies work. So the main manager can find out about all possible metrics
     * and output them in a single file as opposed to each manager creating it's own file. It is
     * because of this fact that the methods in {@link IPerformanceApi} must not change too often for
     * compatibility reasons.
     *
     * @returns a promise of completion.
     *
     * @internal
     */
    async _savePerformanceResults() {
        // Get timing first to not skew the results
        const outputMetrics = {
            nodeTiming: this.api.getNodeTiming(),
            systemInformation: this.api.getSysInfo(),
            metrics: {}
        };
        const metrics = global[constants_1.GLOBAL_SYMBOL].entries();
        for (const [key, value] of metrics) {
            const symbolValue = key.toString();
            // Place into an array to handle the case where the same
            // package might have existed twice.
            if (outputMetrics.metrics[symbolValue] == null) {
                outputMetrics.metrics[symbolValue] = [];
            }
            outputMetrics.metrics[symbolValue].push(value.getMetrics());
        }
        // Require the IO utility at this point to reduce total number of
        // requires in the calling library when performance monitoring
        // is not enabled.
        (await Promise.resolve().then(() => require("../../io"))).saveMetrics(outputMetrics);
    }
}
/**
 * The environment variable that will be checked to determine if performance
 * is enabled.
 */
PerformanceApiManager.ENV_ENABLED = `${constants_1.ENV_PREFIX}_ENABLED`;
/**
 * The value that the environment variable must be in order for performance
 * gathering to be enabled.
 */
PerformanceApiManager.ENV_ENABLED_KEY = "TRUE";
exports.PerformanceApiManager = PerformanceApiManager;
// Register the PERF_TIMING_ENABLED variable
environment_1.Environment.register(PerformanceApiManager.ENV_ENABLED, "");
//# sourceMappingURL=PerformanceApiManager.js.map