/*!
 * This program and the accompanying materials are made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Copyright Contributors to the Zowe Project.
 *
 */
import { IPerformanceApi, IPerformanceApiManager } from "./interfaces";
import { PerformanceApi } from "../api/PerformanceApi";
import { GLOBAL_SYMBOL } from "../../constants";
/**
 * Because of how package dependencies work, there could be multiple instances
 * of this package within an application. To avoid each of these packages having
 * a process.exit hook, we add all of them to the global scope under a unique
 * symbol. The first instance created will be the manager of all of these global
 * packages. This allows for a single `process.on('exit')` hook to be registered.
 *
 * @internal
 *
 * @see {@link PerformanceApiManager._savePerformanceResults}
 */
declare namespace NodeJS {
    /**
     * The global node interface.
     */
    interface Global {
        /**
         * A single global symbol is used to track all instances of an {@link IPerformanceApi}
         * in a map. The key is a symbol defined by each manager and the value is the managed
         * api. When gathering metrics during `process.on('exit')`, each of these apis {@link IPerformanceApi.getMetrics}
         * method will be called and will produce a new entry in the {@link IPerformanceMetrics.metrics}
         * object.
         */
        [GLOBAL_SYMBOL]: Map<symbol, IPerformanceApi>;
    }
}
/**
 * Definition of the global typings needed for this class.
 *
 * @internal
 */
declare var global: NodeJS.Global;
/**
 * Exported so tests can make use of the global type defined here.
 *
 * @internal
 */
export declare type _GlobalType = typeof global;
/**
 * The manager responsible for the {@link PerformanceApi} created by the current package instance.
 *
 * **NOTE:**
 *
 * This class is not intended to be instantiated directly. It should be accessed
 * through the {@link PerfTiming} variable instantiated by this package. Failure
 * to do so will result in lost metrics in the final file output.
 */
export declare class PerformanceApiManager implements IPerformanceApiManager {
    /**
     * The environment variable that will be checked to determine if performance
     * is enabled.
     */
    static readonly ENV_ENABLED: string;
    /**
     * The value that the environment variable must be in order for performance
     * gathering to be enabled.
     */
    static readonly ENV_ENABLED_KEY = "TRUE";
    /**
     * A boolean set by the {@link constructor} indicating if performance is enabled.
     */
    readonly isEnabled: boolean;
    /**
     * The unique identifier of this current package instance. This will be the
     * `name@version` of the closest package.json relative to the location of the
     * first file that imported this package.
     */
    readonly packageUUID: string;
    /**
     * A reference to the performance api that is managed by this specific manager.
     */
    private _api;
    /**
     * A symbol to uniquely identify the {@link _api} in the {@link NodeJS.Global}
     * symbol.
     *
     * @internal
     */
    private _instanceSymbol;
    /**
     * The constructor will instantiate this manager and determine if performance monitoring is
     * enabled.
     *
     * If the monitoring is enabled, it will also calculate the name of the global symbol. Also, if
     * the global symbol has not been instantiated, this manager will be the default one and will
     * be the one responsible for saving all data to the files.
     *
     */
    constructor();
    /**
     * Gets the {@link _api}.
     *
     * **NOTE:**
     *
     * It is recommended that calls to the getApi method are contained within an if check to see
     * if performance is enabled. This method will provide the least overhead for when performance
     * is disabled but will add a some overhead when performance is enabled.
     *
     * **NOTE:**
     *
     * If performance is not enabled, this method will still return a {@link PerformanceApi}
     * object and all methods can still be called the same way with performance enabled or disabled.
     * With this in mind, it is not required that calls to this method are wrapped in a check to see
     * if this is enabled, but it is still recommended.
     *
     * @returns The performance api that is managed by this class.
     */
    readonly api: PerformanceApi;
    /**
     * Responsible for gathering and saving all metrics present within the
     * environment.
     *
     * This method is only called by `process.on('exit')` defined in the {@link constructor} of the
     * main manager. The nodeTiming and systemInformation portions of the {@link IPerformanceMetrics}
     * object are gathered from the {@link _api} of this manager.
     *
     * Metrics are gathered by examining each API present in the {@link NodeJS.global} object. This
     * design comes from the fact that there could be multiple instances of the PerfTiming package
     * due to how npm dependencies work. So the main manager can find out about all possible metrics
     * and output them in a single file as opposed to each manager creating it's own file. It is
     * because of this fact that the methods in {@link IPerformanceApi} must not change too often for
     * compatibility reasons.
     *
     * @returns a promise of completion.
     *
     * @internal
     */
    private _savePerformanceResults;
}
export {};
